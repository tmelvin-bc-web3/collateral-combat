---
phase: 14-events-competitions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/events/EventCountdown.tsx
  - web/src/components/events/FightCard.tsx
  - web/src/components/events/UpcomingEvents.tsx
  - web/src/app/events/page.tsx
  - web/src/hooks/useEvents.ts
autonomous: true

must_haves:
  truths:
    - "Users can see upcoming events in a calendar/list view"
    - "Countdown timers show time remaining until event starts"
    - "Fight card displays featured battles in order"
  artifacts:
    - path: "web/src/app/events/page.tsx"
      provides: "Events calendar/schedule page"
      min_lines: 50
    - path: "web/src/components/events/EventCountdown.tsx"
      provides: "Countdown timer component"
      exports: ["EventCountdown"]
    - path: "web/src/hooks/useEvents.ts"
      provides: "Events data hook"
      exports: ["useEvents", "useEvent"]
  key_links:
    - from: "web/src/app/events/page.tsx"
      to: "web/src/hooks/useEvents.ts"
      via: "hook consumption"
      pattern: "useEvents\\(\\)"
    - from: "web/src/components/events/EventCountdown.tsx"
      to: "props"
      via: "targetTime prop"
      pattern: "targetTime:\\s*number"
---

<objective>
Build the events calendar page and countdown timer components.

Purpose: Enable users to view upcoming events with countdown timers, fulfilling EVENT-02 and EVENT-05 requirements.

Output: Events page at /events with countdown timers and fight card display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-events-competitions/14-RESEARCH.md

Key patterns:
- Server-authoritative timestamps (research pattern 4)
- Wasteland theme styling from CLAUDE.md
- Mobile-first responsive patterns from Phase 11
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Events Hook</name>
  <files>web/src/hooks/useEvents.ts</files>
  <action>
Create useEvents.ts hook following existing hook patterns (usePrices.ts, useProgression.ts):

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { socket } from '@/lib/socket';

export interface FightCardEvent {
  id: string;
  name: string;
  description?: string;
  scheduledStartTime: number;
  registrationOpens: number;
  registrationCloses: number;
  status: 'upcoming' | 'registration_open' | 'in_progress' | 'completed' | 'cancelled';
  entryFeeLamports: number;
  maxParticipants: number;
  prizePoolLamports: number;
  battles: EventBattle[];
}

export interface EventBattle {
  id: string;
  position: number;
  player1Wallet: string;
  player2Wallet: string;
  battleId?: string;
  isMainEvent: boolean;
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
}

export function useEvents() {
  const [events, setEvents] = useState<FightCardEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchEvents = useCallback(async () => {
    try {
      const res = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/events`);
      if (!res.ok) throw new Error('Failed to fetch events');
      const data = await res.json();
      setEvents(data.events || []);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchEvents();

    // Subscribe to event updates
    socket.on('event_update', (data) => {
      setEvents(prev => prev.map(e => e.id === data.eventId ? { ...e, ...data } : e));
    });

    return () => {
      socket.off('event_update');
    };
  }, [fetchEvents]);

  return { events, loading, error, refetch: fetchEvents };
}

export function useEvent(eventId: string) {
  const [event, setEvent] = useState<FightCardEvent | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!eventId) return;

    const fetchEvent = async () => {
      try {
        const res = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/events/${eventId}`);
        if (!res.ok) throw new Error('Event not found');
        const data = await res.json();
        setEvent(data.event);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchEvent();

    // Join event room for updates
    socket.emit('join_event_room', eventId);
    socket.on('event_update', (data) => {
      if (data.eventId === eventId) {
        setEvent(prev => prev ? { ...prev, ...data } : null);
      }
    });

    return () => {
      socket.emit('leave_event_room', eventId);
      socket.off('event_update');
    };
  }, [eventId]);

  return { event, loading, error };
}
```
  </action>
  <verify>TypeScript compiles: `cd web && pnpm typecheck`</verify>
  <done>useEvents.ts exports both hooks, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create Event Components</name>
  <files>web/src/components/events/EventCountdown.tsx, web/src/components/events/FightCard.tsx, web/src/components/events/UpcomingEvents.tsx</files>
  <action>
Create three components in web/src/components/events/ directory:

1. EventCountdown.tsx - Server-synced countdown timer:
```typescript
'use client';

import { useState, useEffect } from 'react';

interface EventCountdownProps {
  targetTime: number;  // Absolute UTC timestamp
  onComplete?: () => void;
  size?: 'sm' | 'md' | 'lg';
}

export function EventCountdown({ targetTime, onComplete, size = 'md' }: EventCountdownProps) {
  const [timeRemaining, setTimeRemaining] = useState(() => Math.max(0, targetTime - Date.now()));

  useEffect(() => {
    const interval = setInterval(() => {
      const remaining = Math.max(0, targetTime - Date.now());
      setTimeRemaining(remaining);
      if (remaining === 0) {
        onComplete?.();
        clearInterval(interval);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [targetTime, onComplete]);

  const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
  const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);

  const sizeClasses = {
    sm: 'text-sm gap-1',
    md: 'text-lg gap-2',
    lg: 'text-2xl gap-3'
  };

  if (timeRemaining === 0) {
    return <span className="text-warning font-bold">LIVE NOW</span>;
  }

  return (
    <div className={`flex items-center font-mono ${sizeClasses[size]}`}>
      {days > 0 && <TimeUnit value={days} label="D" />}
      <TimeUnit value={hours} label="H" />
      <TimeUnit value={minutes} label="M" />
      <TimeUnit value={seconds} label="S" />
    </div>
  );
}

function TimeUnit({ value, label }: { value: number; label: string }) {
  return (
    <div className="flex items-center">
      <span className="bg-black/60 border border-white/10 px-2 py-1 rounded">
        {value.toString().padStart(2, '0')}
      </span>
      <span className="text-white/50 text-xs ml-0.5">{label}</span>
    </div>
  );
}
```

2. FightCard.tsx - Display event with battles:
```typescript
'use client';

import { FightCardEvent, EventBattle } from '@/hooks/useEvents';
import { EventCountdown } from './EventCountdown';

interface FightCardProps {
  event: FightCardEvent;
  onSubscribe?: () => void;
  isSubscribed?: boolean;
}

export function FightCard({ event, onSubscribe, isSubscribed }: FightCardProps) {
  const mainEvent = event.battles.find(b => b.isMainEvent);
  const undercard = event.battles.filter(b => !b.isMainEvent).sort((a, b) => a.position - b.position);

  const formatWallet = (wallet: string) => wallet.slice(0, 4) + '...' + wallet.slice(-4);

  return (
    <div className="bg-black/40 backdrop-blur border border-white/10 rounded-lg overflow-hidden">
      {/* Header */}
      <div className="bg-gradient-to-r from-warning/20 to-transparent p-4 border-b border-white/10">
        <div className="flex justify-between items-start">
          <div>
            <h2 className="text-xl font-bold text-white">{event.name}</h2>
            {event.description && (
              <p className="text-white/60 text-sm mt-1">{event.description}</p>
            )}
          </div>
          <div className="text-right">
            <EventCountdown targetTime={event.scheduledStartTime} size="md" />
            <p className="text-white/50 text-xs mt-1">
              {new Date(event.scheduledStartTime).toLocaleDateString()}
            </p>
          </div>
        </div>
      </div>

      {/* Main Event */}
      {mainEvent && (
        <div className="p-4 bg-warning/5 border-b border-white/10">
          <span className="text-warning text-xs font-bold uppercase tracking-wider">Main Event</span>
          <BattleCard battle={mainEvent} isMain />
        </div>
      )}

      {/* Undercard */}
      {undercard.length > 0 && (
        <div className="p-4 space-y-3">
          <span className="text-white/50 text-xs uppercase tracking-wider">Undercard</span>
          {undercard.map(battle => (
            <BattleCard key={battle.id} battle={battle} />
          ))}
        </div>
      )}

      {/* Subscribe Button */}
      {event.status === 'upcoming' || event.status === 'registration_open' ? (
        <div className="p-4 border-t border-white/10">
          <button
            onClick={onSubscribe}
            className={`w-full py-2 rounded font-medium transition-colors ${
              isSubscribed
                ? 'bg-white/10 text-white/50 cursor-default'
                : 'bg-warning text-black hover:bg-warning/80'
            }`}
            disabled={isSubscribed}
          >
            {isSubscribed ? 'Subscribed for Notifications' : 'Get Notified'}
          </button>
        </div>
      ) : null}
    </div>
  );
}

function BattleCard({ battle, isMain = false }: { battle: EventBattle; isMain?: boolean }) {
  const formatWallet = (wallet: string) => wallet.slice(0, 4) + '...' + wallet.slice(-4);

  return (
    <div className={`flex items-center justify-between py-2 ${isMain ? 'text-lg' : 'text-sm'}`}>
      <span className="text-white font-medium">{formatWallet(battle.player1Wallet)}</span>
      <span className="text-warning font-bold mx-4">VS</span>
      <span className="text-white font-medium">{formatWallet(battle.player2Wallet)}</span>
      <span className={`ml-4 text-xs px-2 py-0.5 rounded ${
        battle.status === 'in_progress' ? 'bg-success text-black' :
        battle.status === 'completed' ? 'bg-white/20 text-white/50' :
        'bg-white/10 text-white/50'
      }`}>
        {battle.status === 'in_progress' ? 'LIVE' : battle.status.toUpperCase()}
      </span>
    </div>
  );
}
```

3. UpcomingEvents.tsx - List/calendar view:
```typescript
'use client';

import { FightCardEvent } from '@/hooks/useEvents';
import { FightCard } from './FightCard';

interface UpcomingEventsProps {
  events: FightCardEvent[];
  onSubscribe?: (eventId: string) => void;
  subscribedIds?: Set<string>;
}

export function UpcomingEvents({ events, onSubscribe, subscribedIds = new Set() }: UpcomingEventsProps) {
  if (events.length === 0) {
    return (
      <div className="text-center py-12 text-white/50">
        <p className="text-lg">No upcoming events</p>
        <p className="text-sm mt-2">Check back soon for scheduled fight cards!</p>
      </div>
    );
  }

  // Group events by date
  const eventsByDate = events.reduce((acc, event) => {
    const date = new Date(event.scheduledStartTime).toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric'
    });
    if (!acc[date]) acc[date] = [];
    acc[date].push(event);
    return acc;
  }, {} as Record<string, FightCardEvent[]>);

  return (
    <div className="space-y-8">
      {Object.entries(eventsByDate).map(([date, dateEvents]) => (
        <div key={date}>
          <h3 className="text-white/50 text-sm uppercase tracking-wider mb-4 border-b border-white/10 pb-2">
            {date}
          </h3>
          <div className="space-y-4">
            {dateEvents.map(event => (
              <FightCard
                key={event.id}
                event={event}
                onSubscribe={() => onSubscribe?.(event.id)}
                isSubscribed={subscribedIds.has(event.id)}
              />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles: `cd web && pnpm typecheck`</verify>
  <done>All three components exist and compile</done>
</task>

<task type="auto">
  <name>Task 3: Create Events Page</name>
  <files>web/src/app/events/page.tsx</files>
  <action>
Create the events page at web/src/app/events/page.tsx:

```typescript
'use client';

import { useState, useCallback } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useEvents } from '@/hooks/useEvents';
import { UpcomingEvents } from '@/components/events/UpcomingEvents';

export default function EventsPage() {
  const { publicKey, connected } = useWallet();
  const { events, loading, error, refetch } = useEvents();
  const [subscribedIds, setSubscribedIds] = useState<Set<string>>(new Set());
  const [subscribing, setSubscribing] = useState(false);

  const handleSubscribe = useCallback(async (eventId: string) => {
    if (!connected || !publicKey) {
      alert('Please connect your wallet to subscribe');
      return;
    }

    setSubscribing(true);
    try {
      const res = await fetch(
        `${process.env.NEXT_PUBLIC_BACKEND_URL}/api/events/${eventId}/subscribe`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wallet: publicKey.toBase58() })
        }
      );

      if (!res.ok) throw new Error('Failed to subscribe');

      setSubscribedIds(prev => new Set([...prev, eventId]));
    } catch (err) {
      console.error('Subscribe error:', err);
      alert('Failed to subscribe to event');
    } finally {
      setSubscribing(false);
    }
  }, [connected, publicKey]);

  return (
    <main className="min-h-screen bg-primary">
      <div className="max-w-4xl mx-auto px-4 py-8">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-white mb-2">Fight Cards</h1>
          <p className="text-white/60">
            Upcoming scheduled events and tournaments. Subscribe to get notified when events start.
          </p>
        </div>

        {/* Status indicators */}
        <div className="flex gap-4 mb-6 text-sm">
          <div className="flex items-center gap-2">
            <span className="w-2 h-2 rounded-full bg-warning"></span>
            <span className="text-white/50">Upcoming</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-2 h-2 rounded-full bg-success"></span>
            <span className="text-white/50">Live</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-2 h-2 rounded-full bg-white/30"></span>
            <span className="text-white/50">Completed</span>
          </div>
        </div>

        {/* Content */}
        {loading ? (
          <div className="flex justify-center py-12">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-warning"></div>
          </div>
        ) : error ? (
          <div className="text-center py-12">
            <p className="text-danger mb-4">{error}</p>
            <button
              onClick={() => refetch()}
              className="text-warning hover:underline"
            >
              Try again
            </button>
          </div>
        ) : (
          <UpcomingEvents
            events={events}
            onSubscribe={handleSubscribe}
            subscribedIds={subscribedIds}
          />
        )}
      </div>
    </main>
  );
}
```

Also ensure the events directory exists and add any needed layout wrapper if necessary.
  </action>
  <verify>Page renders: `cd web && pnpm build` succeeds</verify>
  <done>/events page accessible and displays events list with countdown timers</done>
</task>

</tasks>

<verification>
1. Frontend compiles: `cd web && pnpm typecheck`
2. Frontend builds: `cd web && pnpm build`
3. Page renders at http://localhost:3000/events
4. Countdown timer updates every second
5. Subscribe button works when wallet connected
</verification>

<success_criteria>
- Events page shows upcoming events grouped by date
- Countdown timers count down in real-time
- Fight card displays main event prominently
- Subscribe button allows notification opt-in
- Mobile responsive layout works
</success_criteria>

<output>
After completion, create `.planning/phases/14-events-competitions/14-02-SUMMARY.md`
</output>
