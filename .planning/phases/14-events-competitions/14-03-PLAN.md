---
phase: 14-events-competitions
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - backend/src/services/eventManager.ts
  - backend/src/db/notificationDatabase.ts
  - backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Users receive notifications when events they follow are starting"
    - "Notifications sent 5 minutes before event start"
    - "Users only notified once per event (no spam)"
  artifacts:
    - path: "backend/src/db/notificationDatabase.ts"
      provides: "Event notification type"
      contains: "event_starting"
    - path: "backend/src/services/eventManager.ts"
      provides: "Notification trigger logic"
      contains: "checkUpcomingNotifications"
  key_links:
    - from: "backend/src/services/eventManager.ts"
      to: "backend/src/db/notificationDatabase.ts"
      via: "createNotification call"
      pattern: "createNotification\\("
    - from: "backend/src/services/eventManager.ts"
      to: "backend/src/db/eventDatabase.ts"
      via: "getUnnotifiedSubscribers"
      pattern: "getUnnotifiedSubscribers\\("
---

<objective>
Implement event start notifications for subscribed users.

Purpose: Fulfill EVENT-03 requirement - users receive notifications when events they follow are starting.

Output: Automatic notification delivery 5 minutes before event start to all subscribed users.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-events-competitions/14-RESEARCH.md
@.planning/phases/14-events-competitions/14-01-SUMMARY.md

Key patterns from research:
- Pitfall 4: Notification spam prevention via notified flag
- Existing notificationDatabase.ts helper functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Event Notification Type</name>
  <files>backend/src/db/notificationDatabase.ts</files>
  <action>
Extend notificationDatabase.ts with event notification support:

1. Add 'event_starting' to NotificationType union:
```typescript
export type NotificationType =
  | 'wager_won'
  | 'wager_lost'
  | 'wager_push'
  | 'level_up'
  | 'perk_unlocked'
  | 'perk_expiring'
  | 'streak_bonus'
  | 'streak_lost'
  | 'free_wager_earned'
  | 'leaderboard_rank_change'
  | 'achievement_unlocked'
  | 'tournament_match_ready'  // For Phase 14 tournaments
  | 'event_starting'          // New: event about to start
  | 'system';
```

2. Add helper function for event notifications:
```typescript
export function notifyEventStarting(
  walletAddress: string,
  eventName: string,
  eventId: string,
  startsInMinutes: number
): Notification {
  return createNotification({
    walletAddress,
    type: 'event_starting',
    title: 'Event Starting Soon!',
    message: `${eventName} begins in ${startsInMinutes} minutes!`,
    data: { eventId, eventName, startsInMinutes },
  });
}

export function notifyTournamentMatchReady(
  walletAddress: string,
  tournamentName: string,
  opponentWallet: string,
  round: number,
  roundName: string
): Notification {
  return createNotification({
    walletAddress,
    type: 'tournament_match_ready',
    title: 'Tournament Match Ready!',
    message: `Your ${roundName} match in ${tournamentName} is ready!`,
    data: { tournamentName, opponentWallet, round, roundName },
  });
}
```
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>event_starting type added, helper functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement Notification Ticker in EventManager</name>
  <files>backend/src/services/eventManager.ts</files>
  <action>
Add notification checking to eventManager tick cycle:

1. Add constant at top:
```typescript
const NOTIFICATION_MINUTES_BEFORE = 5;
```

2. Add method to check for upcoming notifications:
```typescript
private checkUpcomingNotifications(): void {
  const now = Date.now();
  const notificationWindow = NOTIFICATION_MINUTES_BEFORE * 60 * 1000;

  // Get events starting within notification window
  const upcomingEvents = db.getEventsStartingBetween(
    now,
    now + notificationWindow
  );

  for (const event of upcomingEvents) {
    // Get subscribers who haven't been notified
    const subscribers = db.getUnnotifiedSubscribers(event.id);

    if (subscribers.length === 0) continue;

    const minutesUntilStart = Math.ceil((event.scheduledStartTime - now) / 60000);

    logger.info('Sending event notifications', {
      eventId: event.id,
      eventName: event.name,
      subscriberCount: subscribers.length,
      minutesUntilStart
    });

    for (const wallet of subscribers) {
      // Create notification
      notifyEventStarting(wallet, event.name, event.id, minutesUntilStart);

      // Mark as notified to prevent spam
      db.markNotified(event.id, wallet);

      // Emit WebSocket notification
      this.emitToWallet(wallet, 'notification', {
        type: 'event_starting',
        eventId: event.id,
        eventName: event.name,
        startsIn: minutesUntilStart * 60 * 1000
      });
    }
  }
}
```

3. Add helper to emit to specific wallet:
```typescript
private walletSocketMap: Map<string, string> = new Map(); // wallet -> socket.id

// Called when socket registers
registerWalletSocket(wallet: string, socketId: string): void {
  this.walletSocketMap.set(wallet, socketId);
}

unregisterWalletSocket(wallet: string): void {
  this.walletSocketMap.delete(wallet);
}

private emitToWallet(wallet: string, event: string, data: any): void {
  const socketId = this.walletSocketMap.get(wallet);
  if (socketId && this.io) {
    this.io.to(socketId).emit(event, data);
  }
}

// Add io instance setter
private io: any = null;
setSocketIO(io: any): void {
  this.io = io;
}
```

4. Modify tick() to call checkUpcomingNotifications:
```typescript
private tick(): void {
  const now = Date.now();

  // Check for events needing notifications
  this.checkUpcomingNotifications();

  // ... existing state transition logic
}
```

5. Add database helper to eventDatabase.ts if not present:
```typescript
// In eventDatabase.ts
export function getEventsStartingBetween(startTime: number, endTime: number): FightCardEvent[] {
  const stmt = db.prepare(`
    SELECT * FROM events
    WHERE scheduled_start_time >= ?
    AND scheduled_start_time <= ?
    AND status IN ('upcoming', 'registration_open')
  `);
  return stmt.all(startTime, endTime).map(mapEventRow);
}
```
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>Notification ticker runs every minute, sends notifications 5 min before event</done>
</task>

<task type="auto">
  <name>Task 3: Wire Socket Registration</name>
  <files>backend/src/index.ts</files>
  <action>
Connect eventManager to socket.io for real-time notifications:

1. Pass socket.io instance to eventManager after initialization:
```typescript
// After io is created
eventManager.setSocketIO(io);
```

2. Add wallet registration on socket connection:
```typescript
// In socket 'connection' handler
socket.on('register_wallet', (wallet: string) => {
  // ... existing registration logic ...

  // Register for event notifications
  eventManager.registerWalletSocket(wallet, socket.id);
});

socket.on('disconnect', () => {
  // ... existing disconnect logic ...

  // Get wallet for this socket and unregister
  // (may need to track socket->wallet mapping)
  eventManager.unregisterWalletSocket(socket.wallet);
});
```

3. Add socket event for joining/leaving event rooms:
```typescript
socket.on('join_event_room', (eventId: string) => {
  socket.join(`event:${eventId}`);
  logger.debug('Socket joined event room', { socketId: socket.id, eventId });
});

socket.on('leave_event_room', (eventId: string) => {
  socket.leave(`event:${eventId}`);
});
```

4. Update eventManager emit to broadcast to event rooms:
```typescript
// In eventManager.ts emit method
private emit(event: EventManagerEvent): void {
  // Notify internal listeners
  for (const listener of this.listeners) {
    try {
      listener(event);
    } catch (err) {
      logger.error('Error in event listener', { error: String(err) });
    }
  }

  // Broadcast to Socket.IO room
  if (this.io && event.eventId) {
    this.io.to(`event:${event.eventId}`).emit('event_update', {
      eventId: event.eventId,
      type: event.type,
      ...event.data
    });
  }
}
```
  </action>
  <verify>`cd backend && npm run dev` starts, socket events working</verify>
  <done>Socket.io integration complete, real-time notifications delivered</done>
</task>

</tasks>

<verification>
1. Backend compiles: `cd backend && npx tsc --noEmit`
2. Backend starts: `cd backend && npm run dev`
3. Create test event starting in 5 minutes
4. Subscribe a wallet to the event
5. Wait for notification (or mock time to test)
6. Verify notification created in database
7. Verify WebSocket notification sent
</verification>

<success_criteria>
- Notifications sent exactly once per subscriber per event
- Notifications sent ~5 minutes before event start
- WebSocket push delivers real-time notification
- Notification stored in database for later retrieval
- No duplicate notifications on server restart
</success_criteria>

<output>
After completion, create `.planning/phases/14-events-competitions/14-03-SUMMARY.md`
</output>
