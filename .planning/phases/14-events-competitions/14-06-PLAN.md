---
phase: 14-events-competitions
plan: 06
type: execute
wave: 2
depends_on: ["14-04"]
files_modified:
  - backend/src/db/tournamentDatabase.ts
  - backend/src/services/tournamentManager.ts
  - web/src/components/tournament/TournamentLeaderboard.tsx
  - web/src/app/tournaments/leaderboard/page.tsx
  - web/src/hooks/useTournamentLeaderboard.ts
  - backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Tournament leaderboard shows rankings across events"
    - "Rankings include win count, earnings, and tournament wins"
    - "Leaderboard updates after each tournament completes"
  artifacts:
    - path: "web/src/components/tournament/TournamentLeaderboard.tsx"
      provides: "Leaderboard display component"
      exports: ["TournamentLeaderboard"]
    - path: "web/src/app/tournaments/leaderboard/page.tsx"
      provides: "Leaderboard page"
      min_lines: 40
    - path: "backend/src/db/tournamentDatabase.ts"
      provides: "Leaderboard queries"
      contains: "getLeaderboard"
  key_links:
    - from: "web/src/app/tournaments/leaderboard/page.tsx"
      to: "web/src/hooks/useTournamentLeaderboard.ts"
      via: "hook consumption"
      pattern: "useTournamentLeaderboard\\(\\)"
    - from: "backend/src/services/tournamentManager.ts"
      to: "backend/src/db/tournamentDatabase.ts"
      via: "leaderboard update"
      pattern: "updateLeaderboard"
---

<objective>
Build the tournament leaderboard showing player rankings across all tournaments.

Purpose: Fulfill TOUR-05 requirement - show rankings, winnings, and tournament victories.

Output: Leaderboard page at /tournaments/leaderboard with comprehensive player stats.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-events-competitions/14-RESEARCH.md
@.planning/phases/14-events-competitions/14-04-SUMMARY.md

Key patterns:
@backend/src/db/ldsDatabase.ts - getLeaderboard pattern
@web/src/app/leaderboard/page.tsx - Existing leaderboard UI pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Leaderboard Schema and Queries</name>
  <files>backend/src/db/tournamentDatabase.ts</files>
  <action>
Extend tournamentDatabase.ts with leaderboard tracking:

1. Add leaderboard table to schema initialization:
```typescript
// Add to db.exec() block:
  -- Tournament leaderboard (aggregated stats)
  CREATE TABLE IF NOT EXISTS tournament_leaderboard (
    wallet_address TEXT PRIMARY KEY,
    tournaments_entered INTEGER DEFAULT 0,
    tournaments_won INTEGER DEFAULT 0,
    total_matches_played INTEGER DEFAULT 0,
    total_matches_won INTEGER DEFAULT 0,
    total_earnings_lamports INTEGER DEFAULT 0,
    best_finish INTEGER,
    last_tournament_at INTEGER,
    updated_at INTEGER NOT NULL
  );

  CREATE INDEX IF NOT EXISTS idx_leaderboard_earnings ON tournament_leaderboard(total_earnings_lamports DESC);
  CREATE INDEX IF NOT EXISTS idx_leaderboard_wins ON tournament_leaderboard(tournaments_won DESC);
```

2. Add leaderboard types:
```typescript
export interface TournamentLeaderboardEntry {
  rank: number;
  walletAddress: string;
  tournamentsEntered: number;
  tournamentsWon: number;
  totalMatchesPlayed: number;
  totalMatchesWon: number;
  totalEarningsLamports: number;
  bestFinish: number | null;
  lastTournamentAt: number | null;
}
```

3. Add prepared statements:
```typescript
const getLeaderboardStmt = db.prepare(`
  SELECT * FROM tournament_leaderboard
  ORDER BY total_earnings_lamports DESC
  LIMIT ? OFFSET ?
`);

const getLeaderboardByWinsStmt = db.prepare(`
  SELECT * FROM tournament_leaderboard
  ORDER BY tournaments_won DESC, total_earnings_lamports DESC
  LIMIT ? OFFSET ?
`);

const getPlayerStatsStmt = db.prepare(`
  SELECT * FROM tournament_leaderboard WHERE wallet_address = ?
`);

const upsertLeaderboardStmt = db.prepare(`
  INSERT INTO tournament_leaderboard (
    wallet_address, tournaments_entered, tournaments_won,
    total_matches_played, total_matches_won, total_earnings_lamports,
    best_finish, last_tournament_at, updated_at
  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  ON CONFLICT(wallet_address) DO UPDATE SET
    tournaments_entered = tournaments_entered + excluded.tournaments_entered,
    tournaments_won = tournaments_won + excluded.tournaments_won,
    total_matches_played = total_matches_played + excluded.total_matches_played,
    total_matches_won = total_matches_won + excluded.total_matches_won,
    total_earnings_lamports = total_earnings_lamports + excluded.total_earnings_lamports,
    best_finish = CASE
      WHEN excluded.best_finish IS NOT NULL AND (best_finish IS NULL OR excluded.best_finish < best_finish)
      THEN excluded.best_finish
      ELSE best_finish
    END,
    last_tournament_at = excluded.last_tournament_at,
    updated_at = excluded.updated_at
`);
```

4. Add leaderboard functions:
```typescript
export function getLeaderboard(
  limit: number = 50,
  offset: number = 0,
  sortBy: 'earnings' | 'wins' = 'earnings'
): TournamentLeaderboardEntry[] {
  const stmt = sortBy === 'wins' ? getLeaderboardByWinsStmt : getLeaderboardStmt;
  const rows = stmt.all(limit, offset) as any[];

  return rows.map((row, index) => ({
    rank: offset + index + 1,
    walletAddress: row.wallet_address,
    tournamentsEntered: row.tournaments_entered,
    tournamentsWon: row.tournaments_won,
    totalMatchesPlayed: row.total_matches_played,
    totalMatchesWon: row.total_matches_won,
    totalEarningsLamports: row.total_earnings_lamports,
    bestFinish: row.best_finish,
    lastTournamentAt: row.last_tournament_at
  }));
}

export function getPlayerTournamentStats(walletAddress: string): TournamentLeaderboardEntry | null {
  const row = getPlayerStatsStmt.get(walletAddress) as any;
  if (!row) return null;

  return {
    rank: 0, // Would need separate query to determine rank
    walletAddress: row.wallet_address,
    tournamentsEntered: row.tournaments_entered,
    tournamentsWon: row.tournaments_won,
    totalMatchesPlayed: row.total_matches_played,
    totalMatchesWon: row.total_matches_won,
    totalEarningsLamports: row.total_earnings_lamports,
    bestFinish: row.best_finish,
    lastTournamentAt: row.last_tournament_at
  };
}

export function updateLeaderboardEntry(
  walletAddress: string,
  tournamentsEntered: number,
  tournamentsWon: number,
  matchesPlayed: number,
  matchesWon: number,
  earnings: number,
  finish: number | null
): void {
  const now = Date.now();
  upsertLeaderboardStmt.run(
    walletAddress,
    tournamentsEntered,
    tournamentsWon,
    matchesPlayed,
    matchesWon,
    earnings,
    finish,
    now,
    now
  );
}
```
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>Leaderboard table and queries added to tournamentDatabase.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update Tournament Manager for Leaderboard</name>
  <files>backend/src/services/tournamentManager.ts, backend/src/index.ts</files>
  <action>
1. Update completeTournament method to update leaderboard:

```typescript
private completeTournament(tournamentId: string, champion: string): void {
  const tournament = db.getTournament(tournamentId);
  if (!tournament) return;

  db.setStatus(tournamentId, 'completed');

  // Calculate prize distribution
  const netPool = calculateDistributablePool(tournament.prizePoolLamports, PLATFORM_FEE_BPS);
  const distribution = TOURNAMENT_PRIZE_DISTRIBUTION[tournament.size];

  // Determine final standings from bracket
  const matches = db.getMatchesByTournament(tournamentId);
  const standings = this.calculateStandings(matches, tournament.size, champion);

  // Distribute prizes and update leaderboard
  for (const { place, wallet } of standings) {
    if (!wallet) continue;

    const prizeInfo = distribution.find(d => d.place === place);
    const payout = prizeInfo ? Math.floor(netPool * prizeInfo.percent / 100) : 0;

    // Count matches for this player
    const playerMatches = matches.filter(m =>
      m.player1Wallet === wallet || m.player2Wallet === wallet
    );
    const matchesWon = matches.filter(m => m.winnerWallet === wallet).length;

    // Update leaderboard
    db.updateLeaderboardEntry(
      wallet,
      1,                    // tournaments entered
      place === 1 ? 1 : 0,  // tournaments won
      playerMatches.length, // matches played
      matchesWon,           // matches won
      payout,               // earnings
      place                 // finish position
    );

    // TODO: Actually pay out via balanceService.creditWinnings
    logger.info('Tournament payout', { tournamentId, wallet, place, payout });
  }

  this.emit({ type: 'tournament_completed', tournamentId, data: { champion, standings } });
}
```

2. Add leaderboard endpoint to backend/src/index.ts:

```typescript
// Tournament leaderboard
app.get('/api/tournaments/leaderboard', (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit as string) || 50, 100);
    const offset = parseInt(req.query.offset as string) || 0;
    const sortBy = (req.query.sort as string) === 'wins' ? 'wins' : 'earnings';

    const leaderboard = db.getLeaderboard(limit, offset, sortBy);
    res.json({ leaderboard });
  } catch (err) {
    logger.error('Error fetching tournament leaderboard', { error: String(err) });
    res.status(500).json({ error: 'Failed to fetch leaderboard' });
  }
});

// Player tournament stats
app.get('/api/tournaments/stats/:wallet', (req, res) => {
  try {
    const stats = db.getPlayerTournamentStats(req.params.wallet);
    if (!stats) {
      return res.json({ stats: null, message: 'No tournament history' });
    }
    res.json({ stats });
  } catch (err) {
    logger.error('Error fetching player tournament stats', { error: String(err) });
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
});
```

Note: Need to import db at top of index.ts:
```typescript
import * as tournamentDb from './db/tournamentDatabase';
```

And use `tournamentDb.getLeaderboard()` in the endpoint.
  </action>
  <verify>`cd backend && npm run dev` starts, `/api/tournaments/leaderboard` returns data</verify>
  <done>Leaderboard updates on tournament completion, API endpoint works</done>
</task>

<task type="auto">
  <name>Task 3: Create Leaderboard UI</name>
  <files>web/src/hooks/useTournamentLeaderboard.ts, web/src/components/tournament/TournamentLeaderboard.tsx, web/src/app/tournaments/leaderboard/page.tsx</files>
  <action>
1. Create web/src/hooks/useTournamentLeaderboard.ts:
```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';

export interface LeaderboardEntry {
  rank: number;
  walletAddress: string;
  tournamentsEntered: number;
  tournamentsWon: number;
  totalMatchesPlayed: number;
  totalMatchesWon: number;
  totalEarningsLamports: number;
  bestFinish: number | null;
}

export function useTournamentLeaderboard(sortBy: 'earnings' | 'wins' = 'earnings') {
  const [entries, setEntries] = useState<LeaderboardEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchLeaderboard = useCallback(async () => {
    try {
      const res = await fetch(
        `${process.env.NEXT_PUBLIC_BACKEND_URL}/api/tournaments/leaderboard?sort=${sortBy}&limit=50`
      );
      if (!res.ok) throw new Error('Failed to fetch leaderboard');
      const data = await res.json();
      setEntries(data.leaderboard || []);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [sortBy]);

  useEffect(() => {
    fetchLeaderboard();
  }, [fetchLeaderboard]);

  return { entries, loading, error, refetch: fetchLeaderboard };
}

export function usePlayerTournamentStats(wallet: string | null) {
  const [stats, setStats] = useState<LeaderboardEntry | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!wallet) return;

    const fetchStats = async () => {
      setLoading(true);
      try {
        const res = await fetch(
          `${process.env.NEXT_PUBLIC_BACKEND_URL}/api/tournaments/stats/${wallet}`
        );
        if (!res.ok) throw new Error('Failed to fetch stats');
        const data = await res.json();
        setStats(data.stats);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, [wallet]);

  return { stats, loading, error };
}
```

2. Create web/src/components/tournament/TournamentLeaderboard.tsx:
```typescript
'use client';

import { LeaderboardEntry } from '@/hooks/useTournamentLeaderboard';

interface TournamentLeaderboardProps {
  entries: LeaderboardEntry[];
  highlightWallet?: string;
  sortBy: 'earnings' | 'wins';
  onSortChange: (sort: 'earnings' | 'wins') => void;
}

export function TournamentLeaderboard({
  entries,
  highlightWallet,
  sortBy,
  onSortChange
}: TournamentLeaderboardProps) {
  const formatWallet = (wallet: string) => wallet.slice(0, 4) + '...' + wallet.slice(-4);
  const formatSol = (lamports: number) => (lamports / 1e9).toFixed(2);

  const getRankBadge = (rank: number) => {
    if (rank === 1) return <span className="text-yellow-400">&#128081;</span>; // Crown
    if (rank === 2) return <span className="text-gray-300">&#129352;</span>; // Silver medal
    if (rank === 3) return <span className="text-amber-600">&#129353;</span>; // Bronze medal
    return <span className="text-white/50">{rank}</span>;
  };

  return (
    <div>
      {/* Sort tabs */}
      <div className="flex gap-2 mb-4">
        <button
          onClick={() => onSortChange('earnings')}
          className={`px-4 py-2 rounded text-sm font-medium transition-colors ${
            sortBy === 'earnings'
              ? 'bg-warning text-black'
              : 'bg-white/10 text-white/50 hover:bg-white/20'
          }`}
        >
          By Earnings
        </button>
        <button
          onClick={() => onSortChange('wins')}
          className={`px-4 py-2 rounded text-sm font-medium transition-colors ${
            sortBy === 'wins'
              ? 'bg-warning text-black'
              : 'bg-white/10 text-white/50 hover:bg-white/20'
          }`}
        >
          By Wins
        </button>
      </div>

      {/* Leaderboard table */}
      <div className="bg-black/40 backdrop-blur border border-white/10 rounded-lg overflow-hidden">
        <table className="w-full">
          <thead className="bg-white/5">
            <tr className="text-white/50 text-sm">
              <th className="py-3 px-4 text-left">Rank</th>
              <th className="py-3 px-4 text-left">Fighter</th>
              <th className="py-3 px-4 text-center">Tournaments</th>
              <th className="py-3 px-4 text-center">Wins</th>
              <th className="py-3 px-4 text-center">Win Rate</th>
              <th className="py-3 px-4 text-right">Earnings</th>
            </tr>
          </thead>
          <tbody>
            {entries.map((entry) => {
              const winRate = entry.totalMatchesPlayed > 0
                ? ((entry.totalMatchesWon / entry.totalMatchesPlayed) * 100).toFixed(0)
                : '0';
              const isHighlighted = entry.walletAddress === highlightWallet;

              return (
                <tr
                  key={entry.walletAddress}
                  className={`border-t border-white/5 ${
                    isHighlighted ? 'bg-warning/10' : 'hover:bg-white/5'
                  }`}
                >
                  <td className="py-3 px-4">
                    <div className="flex items-center gap-2">
                      {getRankBadge(entry.rank)}
                    </div>
                  </td>
                  <td className="py-3 px-4">
                    <span className={`font-mono ${isHighlighted ? 'text-warning' : 'text-white'}`}>
                      {formatWallet(entry.walletAddress)}
                    </span>
                  </td>
                  <td className="py-3 px-4 text-center text-white/70">
                    {entry.tournamentsEntered}
                  </td>
                  <td className="py-3 px-4 text-center">
                    <span className="text-success font-bold">{entry.tournamentsWon}</span>
                  </td>
                  <td className="py-3 px-4 text-center">
                    <span className={`${
                      parseInt(winRate) >= 60 ? 'text-success' :
                      parseInt(winRate) >= 40 ? 'text-white' : 'text-danger'
                    }`}>
                      {winRate}%
                    </span>
                    <span className="text-white/30 text-xs ml-1">
                      ({entry.totalMatchesWon}/{entry.totalMatchesPlayed})
                    </span>
                  </td>
                  <td className="py-3 px-4 text-right">
                    <span className="text-warning font-bold">{formatSol(entry.totalEarningsLamports)}</span>
                    <span className="text-white/50 ml-1">SOL</span>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>

        {entries.length === 0 && (
          <div className="py-12 text-center text-white/50">
            No tournament results yet
          </div>
        )}
      </div>
    </div>
  );
}
```

3. Create web/src/app/tournaments/leaderboard/page.tsx:
```typescript
'use client';

import { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import Link from 'next/link';
import { useTournamentLeaderboard, usePlayerTournamentStats } from '@/hooks/useTournamentLeaderboard';
import { TournamentLeaderboard } from '@/components/tournament/TournamentLeaderboard';

export default function TournamentLeaderboardPage() {
  const { publicKey } = useWallet();
  const [sortBy, setSortBy] = useState<'earnings' | 'wins'>('earnings');

  const { entries, loading, error, refetch } = useTournamentLeaderboard(sortBy);
  const { stats: myStats } = usePlayerTournamentStats(publicKey?.toBase58() || null);

  return (
    <main className="min-h-screen bg-primary">
      <div className="max-w-5xl mx-auto px-4 py-8">
        {/* Header */}
        <div className="flex justify-between items-start mb-8">
          <div>
            <h1 className="text-3xl font-bold text-white mb-2">Tournament Leaderboard</h1>
            <p className="text-white/60">
              Top fighters ranked by tournament performance
            </p>
          </div>
          <Link
            href="/tournaments"
            className="text-warning hover:underline"
          >
            &larr; Back to Tournaments
          </Link>
        </div>

        {/* My stats card (if connected) */}
        {publicKey && myStats && (
          <div className="bg-warning/10 border border-warning/30 rounded-lg p-4 mb-6">
            <div className="flex justify-between items-center">
              <div>
                <p className="text-white/50 text-sm">Your Stats</p>
                <p className="text-warning font-mono">
                  {publicKey.toBase58().slice(0, 4)}...{publicKey.toBase58().slice(-4)}
                </p>
              </div>
              <div className="flex gap-6 text-center">
                <div>
                  <p className="text-2xl font-bold text-success">{myStats.tournamentsWon}</p>
                  <p className="text-white/50 text-xs">Wins</p>
                </div>
                <div>
                  <p className="text-2xl font-bold text-white">{myStats.tournamentsEntered}</p>
                  <p className="text-white/50 text-xs">Entered</p>
                </div>
                <div>
                  <p className="text-2xl font-bold text-warning">
                    {(myStats.totalEarningsLamports / 1e9).toFixed(2)}
                  </p>
                  <p className="text-white/50 text-xs">SOL Earned</p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Leaderboard */}
        {loading ? (
          <div className="flex justify-center py-12">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-warning"></div>
          </div>
        ) : error ? (
          <div className="text-center py-12">
            <p className="text-danger mb-4">{error}</p>
            <button onClick={() => refetch()} className="text-warning hover:underline">
              Try again
            </button>
          </div>
        ) : (
          <TournamentLeaderboard
            entries={entries}
            highlightWallet={publicKey?.toBase58()}
            sortBy={sortBy}
            onSortChange={setSortBy}
          />
        )}
      </div>
    </main>
  );
}
```
  </action>
  <verify>Page builds: `cd web && pnpm build`</verify>
  <done>Leaderboard page renders at /tournaments/leaderboard with sorting and player stats</done>
</task>

</tasks>

<verification>
1. Backend compiles: `cd backend && npx tsc --noEmit`
2. Frontend builds: `cd web && pnpm build`
3. Leaderboard API returns data: `curl http://localhost:3001/api/tournaments/leaderboard`
4. Leaderboard page renders at /tournaments/leaderboard
5. Sorting by earnings and wins works
6. Connected wallet stats appear at top
</verification>

<success_criteria>
- Leaderboard shows top 50 players by default
- Sortable by earnings or tournament wins
- Shows tournaments entered, won, match win rate, earnings
- Current user highlighted if on leaderboard
- Personal stats card shows for connected wallet
</success_criteria>

<output>
After completion, create `.planning/phases/14-events-competitions/14-06-SUMMARY.md`
</output>
