---
phase: 14-events-competitions
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/tournamentDatabase.ts
  - backend/src/services/tournamentManager.ts
  - backend/src/types.ts
  - backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Single elimination bracket supports 8 and 16 players"
    - "Prize pool calculated from entry fees with 5% platform rake"
    - "Tournament matches scheduled at fixed times"
    - "Bracket advances winners to next round automatically"
  artifacts:
    - path: "backend/src/db/tournamentDatabase.ts"
      provides: "Tournament persistence layer"
      exports: ["createTournament", "registerPlayer", "createMatch", "advanceWinner"]
    - path: "backend/src/services/tournamentManager.ts"
      provides: "Tournament lifecycle management"
      exports: ["tournamentManager"]
  key_links:
    - from: "backend/src/services/tournamentManager.ts"
      to: "backend/src/db/tournamentDatabase.ts"
      via: "database operations"
      pattern: "db\\.(create|get|update)"
    - from: "backend/src/services/tournamentManager.ts"
      to: "backend/src/services/battleManager.ts"
      via: "battle creation for matches"
      pattern: "battleManager\\."
---

<objective>
Create tournament database and manager for single-elimination bracket tournaments.

Purpose: Enable 8-16 player single-elimination tournaments with prize pools (TOUR-01, TOUR-02, TOUR-03, TOUR-06).

Output: tournamentDatabase.ts with bracket schema, tournamentManager.ts with lifecycle and prize distribution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-events-competitions/14-RESEARCH.md

Key patterns:
@backend/src/services/ldsManager.ts - Game lifecycle with crash recovery
@backend/src/services/draftTournamentManager.ts - Prize distribution pattern
@backend/src/utils/fees.ts - Platform fee constants
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Tournament Database Schema</name>
  <files>backend/src/db/tournamentDatabase.ts</files>
  <action>
Create tournamentDatabase.ts following existing database patterns:

```typescript
import Database from 'better-sqlite3';
import path from 'path';
import fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

const DATA_DIR = path.join(__dirname, '../../data');
const DB_PATH = path.join(DATA_DIR, 'tournaments.db');

if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

const db = new Database(DB_PATH);
db.pragma('journal_mode = WAL');

// Schema
db.exec(`
  -- Bracket Tournaments
  CREATE TABLE IF NOT EXISTS tournaments (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    format TEXT NOT NULL DEFAULT 'single_elimination',
    size INTEGER NOT NULL,
    entry_fee_lamports INTEGER NOT NULL,
    scheduled_start_time INTEGER NOT NULL,
    registration_opens INTEGER NOT NULL,
    registration_closes INTEGER NOT NULL,
    status TEXT NOT NULL DEFAULT 'upcoming',
    prize_pool_lamports INTEGER DEFAULT 0,
    created_at INTEGER NOT NULL
  );

  -- Tournament registrations
  CREATE TABLE IF NOT EXISTS tournament_registrations (
    tournament_id TEXT NOT NULL,
    wallet_address TEXT NOT NULL,
    seed INTEGER,
    entry_fee_paid_lamports INTEGER NOT NULL,
    registered_at INTEGER NOT NULL,
    PRIMARY KEY (tournament_id, wallet_address),
    FOREIGN KEY (tournament_id) REFERENCES tournaments(id)
  );

  -- Tournament matches (bracket structure)
  CREATE TABLE IF NOT EXISTS tournament_matches (
    id TEXT PRIMARY KEY,
    tournament_id TEXT NOT NULL,
    round INTEGER NOT NULL,
    position INTEGER NOT NULL,
    player1_wallet TEXT,
    player2_wallet TEXT,
    winner_wallet TEXT,
    battle_id TEXT,
    scheduled_time INTEGER,
    status TEXT NOT NULL DEFAULT 'pending',
    FOREIGN KEY (tournament_id) REFERENCES tournaments(id),
    UNIQUE(tournament_id, round, position)
  );

  -- Tournament payouts
  CREATE TABLE IF NOT EXISTS tournament_payouts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tournament_id TEXT NOT NULL,
    wallet_address TEXT NOT NULL,
    place INTEGER NOT NULL,
    payout_lamports INTEGER NOT NULL,
    tx_signature TEXT,
    status TEXT NOT NULL DEFAULT 'pending',
    created_at INTEGER NOT NULL,
    FOREIGN KEY (tournament_id) REFERENCES tournaments(id)
  );

  CREATE INDEX IF NOT EXISTS idx_tournaments_status ON tournaments(status);
  CREATE INDEX IF NOT EXISTS idx_tournaments_start ON tournaments(scheduled_start_time);
  CREATE INDEX IF NOT EXISTS idx_matches_tournament ON tournament_matches(tournament_id);
  CREATE INDEX IF NOT EXISTS idx_matches_status ON tournament_matches(status);
`);

// Types
export type TournamentStatus = 'upcoming' | 'registration_open' | 'in_progress' | 'completed' | 'cancelled';
export type TournamentMatchStatus = 'pending' | 'ready' | 'in_progress' | 'completed';

export interface Tournament {
  id: string;
  name: string;
  format: 'single_elimination';
  size: 8 | 16;
  entryFeeLamports: number;
  scheduledStartTime: number;
  registrationOpens: number;
  registrationCloses: number;
  status: TournamentStatus;
  prizePoolLamports: number;
  createdAt: number;
}

export interface TournamentRegistration {
  tournamentId: string;
  walletAddress: string;
  seed: number | null;
  entryFeePaidLamports: number;
  registeredAt: number;
}

export interface TournamentMatch {
  id: string;
  tournamentId: string;
  round: number;
  position: number;
  player1Wallet: string | null;
  player2Wallet: string | null;
  winnerWallet: string | null;
  battleId: string | null;
  scheduledTime: number | null;
  status: TournamentMatchStatus;
}

// Prepared statements
const insertTournament = db.prepare(`
  INSERT INTO tournaments (id, name, format, size, entry_fee_lamports, scheduled_start_time, registration_opens, registration_closes, status, prize_pool_lamports, created_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);

const getTournamentById = db.prepare(`SELECT * FROM tournaments WHERE id = ?`);
const getUpcomingTournaments = db.prepare(`
  SELECT * FROM tournaments WHERE status IN ('upcoming', 'registration_open') ORDER BY scheduled_start_time ASC
`);
const getActiveTournaments = db.prepare(`
  SELECT * FROM tournaments WHERE status = 'in_progress'
`);
const updateTournamentStatus = db.prepare(`UPDATE tournaments SET status = ? WHERE id = ?`);
const updatePrizePool = db.prepare(`UPDATE tournaments SET prize_pool_lamports = ? WHERE id = ?`);

const insertRegistration = db.prepare(`
  INSERT INTO tournament_registrations (tournament_id, wallet_address, seed, entry_fee_paid_lamports, registered_at)
  VALUES (?, ?, ?, ?, ?)
`);
const getRegistrations = db.prepare(`
  SELECT * FROM tournament_registrations WHERE tournament_id = ? ORDER BY registered_at ASC
`);
const getRegistrationCount = db.prepare(`
  SELECT COUNT(*) as count FROM tournament_registrations WHERE tournament_id = ?
`);
const isPlayerRegistered = db.prepare(`
  SELECT 1 FROM tournament_registrations WHERE tournament_id = ? AND wallet_address = ?
`);
const updateSeed = db.prepare(`
  UPDATE tournament_registrations SET seed = ? WHERE tournament_id = ? AND wallet_address = ?
`);

const insertMatch = db.prepare(`
  INSERT INTO tournament_matches (id, tournament_id, round, position, player1_wallet, player2_wallet, winner_wallet, battle_id, scheduled_time, status)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);
const getMatches = db.prepare(`
  SELECT * FROM tournament_matches WHERE tournament_id = ? ORDER BY round ASC, position ASC
`);
const getMatchById = db.prepare(`SELECT * FROM tournament_matches WHERE id = ?`);
const getMatchByRoundPosition = db.prepare(`
  SELECT * FROM tournament_matches WHERE tournament_id = ? AND round = ? AND position = ?
`);
const updateMatchWinner = db.prepare(`
  UPDATE tournament_matches SET winner_wallet = ?, status = 'completed' WHERE id = ?
`);
const updateMatchStatus = db.prepare(`UPDATE tournament_matches SET status = ? WHERE id = ?`);
const updateMatchBattle = db.prepare(`UPDATE tournament_matches SET battle_id = ?, status = 'in_progress' WHERE id = ?`);
const setMatchPlayers = db.prepare(`
  UPDATE tournament_matches SET player1_wallet = ?, player2_wallet = ? WHERE id = ?
`);

// Functions
export function createTournament(
  name: string,
  size: 8 | 16,
  entryFeeLamports: number,
  scheduledStartTime: number,
  registrationOpens: number,
  registrationCloses: number
): Tournament {
  const id = uuidv4();
  const now = Date.now();

  insertTournament.run(
    id, name, 'single_elimination', size, entryFeeLamports,
    scheduledStartTime, registrationOpens, registrationCloses,
    'upcoming', 0, now
  );

  return {
    id, name, format: 'single_elimination', size,
    entryFeeLamports, scheduledStartTime, registrationOpens, registrationCloses,
    status: 'upcoming', prizePoolLamports: 0, createdAt: now
  };
}

export function getTournament(id: string): Tournament | null {
  const row = getTournamentById.get(id) as any;
  return row ? mapTournamentRow(row) : null;
}

export function getUpcoming(): Tournament[] {
  return (getUpcomingTournaments.all() as any[]).map(mapTournamentRow);
}

export function getActive(): Tournament[] {
  return (getActiveTournaments.all() as any[]).map(mapTournamentRow);
}

export function setStatus(id: string, status: TournamentStatus): void {
  updateTournamentStatus.run(status, id);
}

export function setPrizePool(id: string, lamports: number): void {
  updatePrizePool.run(lamports, id);
}

export function registerPlayer(tournamentId: string, wallet: string, feePaid: number): void {
  insertRegistration.run(tournamentId, wallet, null, feePaid, Date.now());
}

export function getPlayerCount(tournamentId: string): number {
  const row = getRegistrationCount.get(tournamentId) as any;
  return row?.count || 0;
}

export function isRegistered(tournamentId: string, wallet: string): boolean {
  return !!isPlayerRegistered.get(tournamentId, wallet);
}

export function getRegisteredPlayers(tournamentId: string): TournamentRegistration[] {
  return (getRegistrations.all(tournamentId) as any[]).map(mapRegistrationRow);
}

export function setSeed(tournamentId: string, wallet: string, seed: number): void {
  updateSeed.run(seed, tournamentId, wallet);
}

export function createMatch(
  tournamentId: string,
  round: number,
  position: number,
  player1: string | null,
  player2: string | null,
  scheduledTime: number | null
): TournamentMatch {
  const id = uuidv4();
  insertMatch.run(id, tournamentId, round, position, player1, player2, null, null, scheduledTime, 'pending');
  return {
    id, tournamentId, round, position,
    player1Wallet: player1, player2Wallet: player2,
    winnerWallet: null, battleId: null, scheduledTime, status: 'pending'
  };
}

export function getMatchesByTournament(tournamentId: string): TournamentMatch[] {
  return (getMatches.all(tournamentId) as any[]).map(mapMatchRow);
}

export function getMatch(id: string): TournamentMatch | null {
  const row = getMatchById.get(id) as any;
  return row ? mapMatchRow(row) : null;
}

export function getMatchAtPosition(tournamentId: string, round: number, position: number): TournamentMatch | null {
  const row = getMatchByRoundPosition.get(tournamentId, round, position) as any;
  return row ? mapMatchRow(row) : null;
}

export function setMatchWinner(matchId: string, winnerWallet: string): void {
  updateMatchWinner.run(winnerWallet, matchId);
}

export function setMatchStatus(matchId: string, status: TournamentMatchStatus): void {
  updateMatchStatus.run(status, matchId);
}

export function linkBattleToMatch(matchId: string, battleId: string): void {
  updateMatchBattle.run(battleId, matchId);
}

export function setMatchPlayers(matchId: string, player1: string, player2: string): void {
  setMatchPlayers.run(player1, player2, matchId);
}

// Use transaction for atomic bracket advancement
export const advanceWinnerTransaction = db.transaction((matchId: string, winnerWallet: string) => {
  const match = getMatch(matchId);
  if (!match) throw new Error('Match not found');

  // Set winner on current match
  setMatchWinner(matchId, winnerWallet);

  // Find next round match
  const nextRound = match.round + 1;
  const nextPosition = Math.floor(match.position / 2);
  const nextMatch = getMatchAtPosition(match.tournamentId, nextRound, nextPosition);

  if (nextMatch) {
    // Determine if winner goes to player1 or player2 slot
    const isPlayer1Slot = match.position % 2 === 0;
    if (isPlayer1Slot) {
      db.prepare(`UPDATE tournament_matches SET player1_wallet = ? WHERE id = ?`).run(winnerWallet, nextMatch.id);
    } else {
      db.prepare(`UPDATE tournament_matches SET player2_wallet = ? WHERE id = ?`).run(winnerWallet, nextMatch.id);
    }

    // Check if next match is now ready (both players present)
    const updated = getMatch(nextMatch.id);
    if (updated && updated.player1Wallet && updated.player2Wallet) {
      setMatchStatus(nextMatch.id, 'ready');
    }
  }

  return nextMatch;
});

function mapTournamentRow(row: any): Tournament {
  return {
    id: row.id,
    name: row.name,
    format: row.format,
    size: row.size,
    entryFeeLamports: row.entry_fee_lamports,
    scheduledStartTime: row.scheduled_start_time,
    registrationOpens: row.registration_opens,
    registrationCloses: row.registration_closes,
    status: row.status,
    prizePoolLamports: row.prize_pool_lamports,
    createdAt: row.created_at
  };
}

function mapRegistrationRow(row: any): TournamentRegistration {
  return {
    tournamentId: row.tournament_id,
    walletAddress: row.wallet_address,
    seed: row.seed,
    entryFeePaidLamports: row.entry_fee_paid_lamports,
    registeredAt: row.registered_at
  };
}

function mapMatchRow(row: any): TournamentMatch {
  return {
    id: row.id,
    tournamentId: row.tournament_id,
    round: row.round,
    position: row.position,
    player1Wallet: row.player1_wallet,
    player2Wallet: row.player2_wallet,
    winnerWallet: row.winner_wallet,
    battleId: row.battle_id,
    scheduledTime: row.scheduled_time,
    status: row.status
  };
}
```
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>tournamentDatabase.ts exists with full schema and transactional advancement</done>
</task>

<task type="auto">
  <name>Task 2: Create Tournament Manager Service</name>
  <files>backend/src/services/tournamentManager.ts, backend/src/types.ts</files>
  <action>
Create tournamentManager.ts singleton following ldsManager.ts pattern:

1. Add tournament types to backend/src/types.ts (complement database types):
```typescript
export interface TournamentEvent {
  type: 'tournament_created' | 'tournament_started' | 'registration_opened' |
        'player_registered' | 'bracket_generated' | 'match_ready' |
        'match_started' | 'match_completed' | 'tournament_completed';
  tournamentId: string;
  data: any;
}

// Prize distribution by tournament size
export const TOURNAMENT_PRIZE_DISTRIBUTION = {
  8: [
    { place: 1, percent: 50 },
    { place: 2, percent: 30 },
    { place: 3, percent: 10 },  // Split among 2 semifinal losers = 5% each
    { place: 4, percent: 10 },
  ],
  16: [
    { place: 1, percent: 40 },
    { place: 2, percent: 25 },
    { place: 3, percent: 15 },
    { place: 4, percent: 10 },
    { place: 5, percent: 10 },  // Split among quarterfinalist losers
  ],
} as const;
```

2. Create tournamentManager.ts:
```typescript
import * as cron from 'node-cron';
import { v4 as uuidv4 } from 'uuid';
import * as db from '../db/tournamentDatabase';
import { createLogger } from '../utils/logger';
import { PLATFORM_FEE_BPS, calculateDistributablePool } from '../utils/fees';
import { balanceService } from './balanceService';
import { notifyTournamentMatchReady } from '../db/notificationDatabase';
import { TOURNAMENT_PRIZE_DISTRIBUTION, TournamentEvent } from '../types';

const logger = createLogger('tournament-manager');

// Configuration
const REGISTRATION_OPENS_HOURS_BEFORE = 24;
const REGISTRATION_CLOSES_MINUTES_BEFORE = 30;
const MATCH_INTERVAL_MINUTES = 10; // Time between rounds

// Round names for display
const ROUND_NAMES: Record<number, Record<number, string>> = {
  8: { 1: 'Quarterfinal', 2: 'Semifinal', 3: 'Final' },
  16: { 1: 'Round of 16', 2: 'Quarterfinal', 3: 'Semifinal', 4: 'Final' }
};

type TournamentListener = (event: TournamentEvent) => void;

class TournamentManager {
  private listeners: Set<TournamentListener> = new Set();
  private schedulerTask: cron.ScheduledTask | null = null;
  private tickerInterval: NodeJS.Timeout | null = null;
  private initialized = false;
  private io: any = null;

  initialize(): void {
    if (this.initialized) {
      logger.warn('TournamentManager already initialized');
      return;
    }

    logger.info('Initializing TournamentManager');

    // Resume any in-progress tournaments
    const active = db.getActive();
    for (const tournament of active) {
      logger.info('Resuming tournament', { id: tournament.id, name: tournament.name });
    }

    // Schedule daily tournaments at fixed times (12:00 UTC and 20:00 UTC)
    this.schedulerTask = cron.schedule('0 12,20 * * *', () => {
      this.createScheduledTournaments();
    }, { timezone: 'UTC' });

    // Start ticker for state transitions
    this.tickerInterval = setInterval(() => this.tick(), 60 * 1000);

    this.initialized = true;
    logger.info('TournamentManager initialized');
  }

  setSocketIO(io: any): void {
    this.io = io;
  }

  private createScheduledTournaments(): void {
    const now = Date.now();
    const startTime = now + 2 * 60 * 60 * 1000; // 2 hours from now
    const registrationOpens = now;
    const registrationCloses = startTime - REGISTRATION_CLOSES_MINUTES_BEFORE * 60 * 1000;

    // Create both 8 and 16 player tournaments
    for (const size of [8, 16] as const) {
      const entryFee = size === 8 ? 0.1 * 1e9 : 0.25 * 1e9; // 0.1 SOL for 8p, 0.25 SOL for 16p
      const name = `${size}-Player Tournament - ${new Date(startTime).toISOString().split('T')[0]}`;

      const tournament = db.createTournament(
        name, size, entryFee, startTime, registrationOpens, registrationCloses
      );

      logger.info('Created scheduled tournament', {
        id: tournament.id,
        name: tournament.name,
        size,
        startTime: new Date(startTime).toISOString()
      });

      this.emit({ type: 'tournament_created', tournamentId: tournament.id, data: tournament });
    }
  }

  private tick(): void {
    const now = Date.now();
    const upcoming = db.getUpcoming();

    for (const tournament of upcoming) {
      // Open registration
      if (tournament.status === 'upcoming' && now >= tournament.registrationOpens) {
        db.setStatus(tournament.id, 'registration_open');
        this.emit({ type: 'registration_opened', tournamentId: tournament.id, data: tournament });
      }

      // Close registration and start tournament
      if (tournament.status === 'registration_open' && now >= tournament.scheduledStartTime) {
        this.startTournament(tournament.id);
      }
    }

    // Check for ready matches that need battles created
    const active = db.getActive();
    for (const tournament of active) {
      this.checkReadyMatches(tournament.id);
    }
  }

  async registerPlayer(tournamentId: string, wallet: string): Promise<void> {
    const tournament = db.getTournament(tournamentId);
    if (!tournament) throw new Error('Tournament not found');
    if (tournament.status !== 'registration_open') throw new Error('Registration not open');
    if (db.isRegistered(tournamentId, wallet)) throw new Error('Already registered');

    const count = db.getPlayerCount(tournamentId);
    if (count >= tournament.size) throw new Error('Tournament full');

    // Verify balance and lock entry fee
    const balance = await balanceService.getOnChainBalance(wallet);
    if (balance < tournament.entryFeeLamports) throw new Error('Insufficient balance');

    // TODO: Lock funds via on-chain call
    // await balanceService.lockFunds(wallet, tournament.entryFeeLamports);

    db.registerPlayer(tournamentId, wallet, tournament.entryFeeLamports);

    // Update prize pool
    const newPrizePool = tournament.prizePoolLamports + tournament.entryFeeLamports;
    db.setPrizePool(tournamentId, newPrizePool);

    this.emit({
      type: 'player_registered',
      tournamentId,
      data: { wallet, playerCount: count + 1, maxPlayers: tournament.size }
    });
  }

  private startTournament(tournamentId: string): void {
    const tournament = db.getTournament(tournamentId);
    if (!tournament) return;

    const players = db.getRegisteredPlayers(tournamentId);
    if (players.length < tournament.size) {
      logger.info('Not enough players, cancelling tournament', {
        tournamentId,
        registered: players.length,
        required: tournament.size
      });
      this.cancelTournament(tournamentId, 'Not enough players');
      return;
    }

    // TODO: Seed players by ELO (for now, random shuffle)
    const shuffled = players.sort(() => Math.random() - 0.5);
    shuffled.forEach((p, i) => db.setSeed(tournamentId, p.walletAddress, i + 1));

    // Generate bracket
    this.generateBracket(tournamentId, shuffled.map(p => p.walletAddress));

    db.setStatus(tournamentId, 'in_progress');
    this.emit({ type: 'tournament_started', tournamentId, data: tournament });
    this.emit({ type: 'bracket_generated', tournamentId, data: db.getMatchesByTournament(tournamentId) });
  }

  private generateBracket(tournamentId: string, players: string[]): void {
    const size = players.length as 8 | 16;
    const rounds = Math.log2(size);
    const now = Date.now();

    // Seed players for fairness: 1v8, 4v5, 3v6, 2v7 for 8-player
    const seeded = this.seedPlayers(players, size);

    // Create first round matches
    for (let i = 0; i < size / 2; i++) {
      const scheduledTime = now + MATCH_INTERVAL_MINUTES * 60 * 1000;
      db.createMatch(
        tournamentId, 1, i,
        seeded[i * 2], seeded[i * 2 + 1],
        scheduledTime
      );
    }

    // Create placeholder matches for subsequent rounds
    for (let round = 2; round <= rounds; round++) {
      const matchesInRound = size / Math.pow(2, round);
      for (let pos = 0; pos < matchesInRound; pos++) {
        const scheduledTime = now + (round * MATCH_INTERVAL_MINUTES) * 60 * 1000;
        db.createMatch(tournamentId, round, pos, null, null, scheduledTime);
      }
    }

    // Mark first round matches as ready
    const firstRoundMatches = db.getMatchesByTournament(tournamentId).filter(m => m.round === 1);
    for (const match of firstRoundMatches) {
      db.setMatchStatus(match.id, 'ready');
      // Notify players
      if (match.player1Wallet && match.player2Wallet) {
        const roundName = ROUND_NAMES[size][1];
        const tournament = db.getTournament(tournamentId);
        notifyTournamentMatchReady(match.player1Wallet, tournament?.name || '', match.player2Wallet, 1, roundName);
        notifyTournamentMatchReady(match.player2Wallet, tournament?.name || '', match.player1Wallet, 1, roundName);
        this.emit({ type: 'match_ready', tournamentId, data: match });
      }
    }
  }

  private seedPlayers(players: string[], size: 8 | 16): string[] {
    // Standard seeding: #1 vs #8, #4 vs #5, #3 vs #6, #2 vs #7
    if (size === 8) {
      const positions = [0, 7, 3, 4, 2, 5, 1, 6];
      return positions.map(i => players[i]);
    }
    // 16-player seeding
    const positions = [0, 15, 7, 8, 3, 12, 4, 11, 2, 13, 5, 10, 6, 9, 1, 14];
    return positions.map(i => players[i]);
  }

  private checkReadyMatches(tournamentId: string): void {
    const matches = db.getMatchesByTournament(tournamentId);
    const readyMatches = matches.filter(m => m.status === 'ready' && !m.battleId);

    for (const match of readyMatches) {
      // TODO: Create actual battle via battleManager
      // const battle = await battleManager.createTournamentBattle(match.player1Wallet, match.player2Wallet, ...);
      // db.linkBattleToMatch(match.id, battle.id);
      logger.info('Match ready for battle creation', {
        matchId: match.id,
        player1: match.player1Wallet,
        player2: match.player2Wallet
      });
    }
  }

  onMatchComplete(matchId: string, winnerWallet: string): void {
    const match = db.getMatch(matchId);
    if (!match) return;

    // Use transaction to advance winner atomically
    const nextMatch = db.advanceWinnerTransaction(matchId, winnerWallet);

    this.emit({
      type: 'match_completed',
      tournamentId: match.tournamentId,
      data: { matchId, winnerWallet, nextMatchId: nextMatch?.id }
    });

    // Check if tournament is complete
    const tournament = db.getTournament(match.tournamentId);
    if (!tournament) return;

    const totalRounds = Math.log2(tournament.size);
    if (match.round === totalRounds) {
      // This was the final - tournament is complete
      this.completeTournament(match.tournamentId, winnerWallet);
    } else if (nextMatch) {
      // Notify next match is ready
      const updatedNext = db.getMatch(nextMatch.id);
      if (updatedNext && updatedNext.player1Wallet && updatedNext.player2Wallet) {
        const roundName = ROUND_NAMES[tournament.size][updatedNext.round];
        notifyTournamentMatchReady(updatedNext.player1Wallet, tournament.name, updatedNext.player2Wallet, updatedNext.round, roundName);
        notifyTournamentMatchReady(updatedNext.player2Wallet, tournament.name, updatedNext.player1Wallet, updatedNext.round, roundName);
        this.emit({ type: 'match_ready', tournamentId: match.tournamentId, data: updatedNext });
      }
    }
  }

  private completeTournament(tournamentId: string, champion: string): void {
    const tournament = db.getTournament(tournamentId);
    if (!tournament) return;

    db.setStatus(tournamentId, 'completed');

    // Calculate prize distribution
    const netPool = calculateDistributablePool(tournament.prizePoolLamports, PLATFORM_FEE_BPS);
    const distribution = TOURNAMENT_PRIZE_DISTRIBUTION[tournament.size];

    // Determine final standings from bracket
    const matches = db.getMatchesByTournament(tournamentId);
    const standings = this.calculateStandings(matches, tournament.size, champion);

    // Distribute prizes
    for (const { place, wallet } of standings) {
      const prizeInfo = distribution.find(d => d.place === place);
      if (prizeInfo && wallet) {
        const payout = Math.floor(netPool * prizeInfo.percent / 100);
        // TODO: Actually pay out via balanceService.creditWinnings
        logger.info('Tournament payout', { tournamentId, wallet, place, payout });
      }
    }

    this.emit({ type: 'tournament_completed', tournamentId, data: { champion, standings } });
  }

  private calculateStandings(matches: db.TournamentMatch[], size: 8 | 16, champion: string): { place: number; wallet: string }[] {
    const standings: { place: number; wallet: string }[] = [{ place: 1, wallet: champion }];

    // Find final match loser (2nd place)
    const totalRounds = Math.log2(size);
    const finalMatch = matches.find(m => m.round === totalRounds);
    if (finalMatch) {
      const runnerUp = finalMatch.player1Wallet === champion ? finalMatch.player2Wallet : finalMatch.player1Wallet;
      if (runnerUp) standings.push({ place: 2, wallet: runnerUp });
    }

    // Semifinal losers split 3rd/4th
    const semifinalMatches = matches.filter(m => m.round === totalRounds - 1);
    let place = 3;
    for (const match of semifinalMatches) {
      if (match.winnerWallet && match.player1Wallet && match.player2Wallet) {
        const loser = match.player1Wallet === match.winnerWallet ? match.player2Wallet : match.player1Wallet;
        standings.push({ place: place++, wallet: loser });
      }
    }

    return standings;
  }

  private cancelTournament(tournamentId: string, reason: string): void {
    db.setStatus(tournamentId, 'cancelled');
    // TODO: Refund all registered players
    logger.info('Tournament cancelled', { tournamentId, reason });
  }

  // Public API
  getTournament(id: string) { return db.getTournament(id); }
  getUpcomingTournaments() { return db.getUpcoming(); }
  getActiveTournaments() { return db.getActive(); }
  getTournamentMatches(id: string) { return db.getMatchesByTournament(id); }

  subscribe(listener: TournamentListener): void { this.listeners.add(listener); }
  unsubscribe(listener: TournamentListener): void { this.listeners.delete(listener); }

  private emit(event: TournamentEvent): void {
    for (const listener of this.listeners) {
      try { listener(event); } catch (err) { logger.error('Listener error', { error: String(err) }); }
    }
    if (this.io) {
      this.io.to(`tournament:${event.tournamentId}`).emit('tournament_update', event);
    }
  }

  shutdown(): void {
    if (this.schedulerTask) this.schedulerTask.stop();
    if (this.tickerInterval) clearInterval(this.tickerInterval);
    this.initialized = false;
  }
}

export const tournamentManager = new TournamentManager();
```
  </action>
  <verify>TypeScript compiles: `cd backend && npx tsc --noEmit`</verify>
  <done>tournamentManager.ts exists with full lifecycle and prize distribution</done>
</task>

<task type="auto">
  <name>Task 3: Wire Tournament Manager to Backend</name>
  <files>backend/src/index.ts</files>
  <action>
Integrate tournamentManager into the backend server:

1. Import tournamentManager:
```typescript
import { tournamentManager } from './services/tournamentManager';
```

2. Initialize in server startup:
```typescript
// Initialize Tournament Manager
tournamentManager.initialize();
tournamentManager.setSocketIO(io);
```

3. Add REST endpoints:
- GET /api/tournaments - List upcoming/active tournaments (public)
- GET /api/tournaments/:id - Get tournament with matches (public)
- POST /api/tournaments/:id/register - Register for tournament (authenticated)

4. Add WebSocket events:
```typescript
socket.on('join_tournament_room', (tournamentId: string) => {
  socket.join(`tournament:${tournamentId}`);
});

socket.on('leave_tournament_room', (tournamentId: string) => {
  socket.leave(`tournament:${tournamentId}`);
});
```

5. Connect battle completion to tournament advancement:
When a battle completes that is linked to a tournament match:
```typescript
// In battle completion handler (battleManager or wherever battles complete)
if (battle.tournamentMatchId) {
  tournamentManager.onMatchComplete(battle.tournamentMatchId, winnerWallet);
}
```
  </action>
  <verify>`cd backend && npm run dev` starts, tournament endpoints respond</verify>
  <done>Tournament endpoints work, manager initializes, WebSocket rooms functional</done>
</task>

</tasks>

<verification>
1. Backend compiles: `cd backend && npx tsc --noEmit`
2. Backend starts: `cd backend && npm run dev`
3. List tournaments: `curl http://localhost:3001/api/tournaments`
4. Database tables created in data/tournaments.db
5. Scheduled tournaments appear in list
</verification>

<success_criteria>
- Tournament database persists all state (crash recovery)
- Registration tracks entry fees and updates prize pool
- Bracket generation seeds players correctly
- Winner advancement uses database transaction (no race conditions)
- Prize distribution calculates correctly with 5% rake
</success_criteria>

<output>
After completion, create `.planning/phases/14-events-competitions/14-04-SUMMARY.md`
</output>
