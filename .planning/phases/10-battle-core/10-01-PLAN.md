---
phase: 10-battle-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/eloDatabase.ts
  - backend/src/services/eloService.ts
  - backend/src/services/battleManager.ts
  - backend/src/types.ts
autonomous: true

must_haves:
  truths:
    - "New player starts with 1200 ELO rating"
    - "ELO changes after each battle based on opponent rating"
    - "Player with <10 battles is in protected matchmaking tier"
    - "Protected tier players match ONLY with other protected tier players"
    - "Matchmaking groups players by ELO tier (bronze/silver/gold/platinum/diamond)"
  artifacts:
    - path: "backend/src/db/eloDatabase.ts"
      provides: "ELO storage and queries"
      exports: ["getElo", "updateElo", "getBattleCount", "getEloTier"]
    - path: "backend/src/services/eloService.ts"
      provides: "ELO calculation logic"
      exports: ["calculateEloChange", "getEloTier", "shouldProtectPlayer"]
  key_links:
    - from: "backend/src/services/battleManager.ts"
      to: "eloService.calculateEloChange"
      via: "endBattle() calls updateElo"
      pattern: "eloService\\.calculateEloChange"
    - from: "backend/src/services/battleManager.ts"
      to: "eloService.getEloTier"
      via: "getMatchmakingKey includes ELO tier"
      pattern: "getMatchmakingKey.*eloTier"
---

<objective>
Add ELO rating system for skill-based matchmaking

Purpose: Enable fair matches by grouping players of similar skill levels. New players get protected matching until they complete 10 battles.
Output: ELO database, calculation service, and matchmaking integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-battle-core/10-RESEARCH.md

# Source code for extension
@backend/src/services/battleManager.ts
@backend/src/db/progressionDatabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ELO database and service</name>
  <files>
    backend/src/db/eloDatabase.ts
    backend/src/services/eloService.ts
    backend/src/types.ts
  </files>
  <action>
Create eloDatabase.ts following progressionDatabase.ts patterns:
- Table `user_elo`: wallet (PK), elo (default 1200), battle_count, wins, losses, created_at, updated_at
- Functions: getElo(wallet), updateElo(wallet, newElo, isWin), getBattleCount(wallet), initializeEloDatabase()
- Initialize DB on import

Create eloService.ts with:
- K_FACTOR_NEW = 32, K_FACTOR_ESTABLISHED = 16 (new = less than 30 battles)
- calculateEloChange(winnerElo, loserElo, winnerBattleCount): { winnerGain, loserLoss }
  - Use Elo formula: expectedWin = 1 / (1 + 10^((loserElo - winnerElo) / 400))
  - change = K * (1 - expectedWin)
- getEloTier(elo): 'bronze' (<1000) | 'silver' (<1500) | 'gold' (<2000) | 'platinum' (<2500) | 'diamond' (2500+)
- shouldProtectPlayer(battleCount): returns true if battleCount < 10

Add to types.ts:
- EloTier type: 'bronze' | 'silver' | 'gold' | 'platinum' | 'diamond' | 'protected'
- UserElo interface: { wallet, elo, battleCount, wins, losses, tier }
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Database initializes without error on import
  </verify>
  <done>
ELO database created with user_elo table, eloService exports calculateEloChange and getEloTier functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ELO into matchmaking with protected tier isolation</name>
  <files>
    backend/src/services/battleManager.ts
  </files>
  <action>
Modify battleManager.ts:

1. Import eloService and eloDatabase

2. Update getMatchmakingKey() to be async and include ELO tier:
```typescript
private async getMatchmakingKey(config: BattleConfig, walletAddress: string): Promise<string> {
  const battleCount = eloDatabase.getBattleCount(walletAddress);
  if (eloService.shouldProtectPlayer(battleCount)) {
    // CRITICAL: Protected players get their own queue key
    // This ensures they ONLY match with other protected players
    return `${config.entryFee}-${config.duration}-${config.mode}-protected`;
  }
  const elo = eloDatabase.getElo(walletAddress);
  const tier = eloService.getEloTier(elo);
  return `${config.entryFee}-${config.duration}-${config.mode}-${tier}`;
}
```

3. Update queueForMatchmaking() to be async and use new key function

4. Update processMatchmaking() to be async

5. Update endBattle() to call ELO update:
```typescript
// After winner determined
if (battle.players.length === 2) {
  const winner = battle.players.find(p => p.walletAddress === battle.winnerId);
  const loser = battle.players.find(p => p.walletAddress !== battle.winnerId);
  if (winner && loser) {
    const winnerElo = eloDatabase.getElo(winner.walletAddress);
    const loserElo = eloDatabase.getElo(loser.walletAddress);
    const winnerBattleCount = eloDatabase.getBattleCount(winner.walletAddress);
    const { winnerGain, loserLoss } = eloService.calculateEloChange(winnerElo, loserElo, winnerBattleCount);
    eloDatabase.updateElo(winner.walletAddress, winnerElo + winnerGain, true);
    eloDatabase.updateElo(loser.walletAddress, loserElo - loserLoss, false);
  }
}
```

Note: Keep backward compatible - if ELO lookup fails, fall back to tier-less matchmaking key.

**CRITICAL for MATCH-05 compliance:** The protected tier isolation works because:
- Protected players get queue key ending in `-protected`
- Non-protected players get queue key ending in their ELO tier (bronze/silver/etc.)
- Matchmaking only pairs players with IDENTICAL queue keys
- Therefore protected players can NEVER be matched with non-protected players
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Manually test: Start backend, check that matchmaking logs include tier in queue key
Verify protected isolation: `grep -n "protected" backend/src/services/battleManager.ts` shows queue key includes 'protected' suffix for players with <10 battles
Verify matchmaking logic only matches same keys: Review processMatchmaking() confirms it groups by identical queue key
  </verify>
  <done>
Matchmaking uses ELO tiers, new players with <10 battles get 'protected' tier key that isolates them from veteran players, ELO updates after battle end
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ELO API endpoint</name>
  <files>
    backend/src/index.ts
  </files>
  <action>
Add REST endpoint for fetching user ELO:

```typescript
// GET /api/elo/:wallet
app.get('/api/elo/:wallet', (req, res) => {
  const wallet = req.params.wallet;
  try {
    const elo = eloDatabase.getElo(wallet);
    const battleCount = eloDatabase.getBattleCount(wallet);
    const tier = eloService.getEloTier(elo);
    const isProtected = eloService.shouldProtectPlayer(battleCount);
    res.json({
      wallet,
      elo,
      battleCount,
      tier: isProtected ? 'protected' : tier,
      wins: eloDatabase.getWins(wallet),
      losses: eloDatabase.getLosses(wallet)
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch ELO' });
  }
});
```

Import eloDatabase and eloService at top of file.
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Start backend and test: `curl http://localhost:3001/api/elo/test-wallet` returns JSON with elo=1200
  </verify>
  <done>
API endpoint returns user's ELO rating, battle count, tier, and protection status
  </done>
</task>

</tasks>

<verification>
- [ ] `cd backend && npm run typecheck` passes
- [ ] Backend starts without errors
- [ ] ELO table exists in data/elo.db
- [ ] New wallet returns elo=1200, battleCount=0, tier='protected'
- [ ] Protected tier key format: `{entryFee}-{duration}-{mode}-protected`
- [ ] Non-protected tier key format: `{entryFee}-{duration}-{mode}-{eloTier}`
- [ ] Matchmaking only pairs players with identical queue keys (verified via code review)
- [ ] After hypothetical battle, ELO would update (verify via code review)
</verification>

<success_criteria>
1. ELO database persists ratings across restarts
2. New players get 1200 starting ELO
3. Players with <10 battles are in 'protected' tier for matchmaking
4. Protected tier players can ONLY match with other protected tier players (queue key isolation)
5. Matchmaking key includes ELO tier
6. Battle end updates both players' ELO ratings
7. API endpoint returns ELO data for any wallet
</success_criteria>

<output>
After completion, create `.planning/phases/10-battle-core/10-01-SUMMARY.md`
</output>
