---
phase: 10-battle-core
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/battleManager.ts
  - backend/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Liquidation of ALL capital ends battle instantly with loser determined"
    - "Battle continues if only partial capital is liquidated"
    - "Zero capital fighter loses even if opponent has negative PnL"
  artifacts:
    - path: "backend/src/services/battleManager.ts"
      provides: "Instant loss on total liquidation"
      contains: "checkInstantLoss"
  key_links:
    - from: "backend/src/services/battleManager.ts:updateAccountValue"
      to: "endBattle"
      via: "Total liquidation triggers instant end"
      pattern: "totalValue <= 0"
---

<objective>
Implement instant battle loss when fighter loses all capital through liquidation

Purpose: Per CONTEXT.md, if a fighter loses ALL capital through liquidations, the battle ends immediately and they lose. This creates high-stakes moments where overleveraged positions can end battles early.
Output: Instant loss detection in updateAccountValue, early battle termination
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-battle-core/10-CONTEXT.md

# Source code for modification
@backend/src/services/battleManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add total capital check after liquidation</name>
  <files>
    backend/src/services/battleManager.ts
    backend/src/types.ts
  </files>
  <action>
Modify battleManager.ts:

1. Add new battle end reason to types.ts:
```typescript
export type BattleEndReason = 'time' | 'liquidation' | 'forfeit';
```

2. Add endReason to Battle interface in types.ts:
```typescript
export interface Battle {
  // ... existing fields ...
  endReason?: BattleEndReason;
}
```

3. Create method to check if player has zero capital:
```typescript
private checkInstantLoss(battle: Battle, player: BattlePlayer): boolean {
  // Calculate total account value (balance + margin in positions + unrealized PnL)
  const marginInPositions = player.account.positions.reduce(
    (sum, p) => sum + (p.size / p.leverage),
    0
  );
  const unrealizedPnl = player.account.positions.reduce(
    (sum, p) => sum + p.unrealizedPnl,
    0
  );
  const totalValue = player.account.balance + marginInPositions + unrealizedPnl;

  // If total account value is <= 0, player has been liquidated out
  return totalValue <= 0;
}
```

4. Modify updateAccountValue() to return boolean indicating if liquidation happened:
```typescript
private updateAccountValue(player: BattlePlayer): boolean {
  let totalUnrealizedPnl = 0;
  let hadLiquidation = false;

  player.account.positions.forEach(position => {
    const currentPrice = priceService.getPrice(position.asset);
    position.currentPrice = currentPrice;

    // Calculate unrealized P&L
    const priceChange = (currentPrice - position.entryPrice) / position.entryPrice;
    const pnlPercent = position.side === 'long' ? priceChange : -priceChange;
    position.unrealizedPnlPercent = pnlPercent * position.leverage * 100;
    position.unrealizedPnl = position.size * pnlPercent * position.leverage;

    totalUnrealizedPnl += position.unrealizedPnl;

    // Check for liquidation
    if (position.side === 'long' && currentPrice <= position.liquidationPrice) {
      this.liquidatePosition(player, position);
      hadLiquidation = true;
    } else if (position.side === 'short' && currentPrice >= position.liquidationPrice) {
      this.liquidatePosition(player, position);
      hadLiquidation = true;
    }
  });

  // Update total account value
  const marginInPositions = player.account.positions.reduce(
    (sum, p) => sum + (p.size / p.leverage),
    0
  );
  const totalValue = player.account.balance + marginInPositions + totalUnrealizedPnl;
  player.account.totalPnlPercent = ((totalValue - player.account.startingBalance) / player.account.startingBalance) * 100;

  // Return whether a liquidation happened for instant loss check
  return hadLiquidation;
}
```

5. Update ALL callers of updateAccountValue to handle the new boolean return:

   a. In openPosition(): The call `this.updateAccountValue(player);` does not use the return value - no change needed (void context).

   b. In closePosition(): The call `this.updateAccountValue(player);` does not use the return value - no change needed (void context).

   c. In closeAllPositionsForPlayer(): The call `this.updateAccountValue(player);` does not use the return value - no change needed (void context).

   d. In updateAllAccounts(): This is the key caller that needs to USE the return value:
```typescript
updateAllAccounts(): void {
  this.battles.forEach((battle, battleId) => {
    if (battle.status === 'active') {
      let instantLossPlayer: string | null = null;

      battle.players.forEach(player => {
        const hadLiquidation = this.updateAccountValue(player);

        // After liquidation, check if player has zero capital
        if (hadLiquidation && this.checkInstantLoss(battle, player)) {
          instantLossPlayer = player.walletAddress;
        }
      });

      // If any player hit instant loss, end battle immediately
      if (instantLossPlayer) {
        console.log(`[Battle] INSTANT LOSS: ${instantLossPlayer} has zero capital!`);
        this.endBattleByLiquidation(battleId, instantLossPlayer);
      } else {
        this.notifyListeners(battle);
      }
    }
  });
}
```

6. Add endBattleByLiquidation method:
```typescript
private async endBattleByLiquidation(battleId: string, loserWallet: string): Promise<void> {
  const battle = this.battles.get(battleId);
  if (!battle || battle.status !== 'active') return;

  console.log(`[Battle] Ending battle ${battleId} due to liquidation of ${loserWallet}`);

  // Clear the normal battle timer
  const timer = this.battleTimers.get(battleId);
  if (timer) {
    clearTimeout(timer);
    this.battleTimers.delete(battleId);
  }

  // Set the loser's final PnL to -100% (total loss)
  battle.players.forEach(player => {
    if (player.walletAddress === loserWallet) {
      player.finalPnl = -100;
      player.rank = 2;
    } else {
      // Winner gets their current P&L (close all positions at current price)
      this.closeAllPositionsForPlayer(player);
      player.rank = 1;
    }
  });

  // Winner is the other player
  battle.winnerId = battle.players.find(p => p.walletAddress !== loserWallet)?.walletAddress;
  battle.endReason = 'liquidation';

  // Use existing endBattle logic for settlement
  await this.endBattle(battleId);

  // Send liquidation-specific chat message
  chatService.sendSystemMessage(battleId, `LIQUIDATION! ${loserWallet.slice(0, 4)}...${loserWallet.slice(-4)} wiped out!`);
}

private closeAllPositionsForPlayer(player: BattlePlayer): void {
  const positionsToClose = [...player.account.positions];
  positionsToClose.forEach(position => {
    const currentPrice = priceService.getPrice(position.asset);
    const priceChange = (currentPrice - position.entryPrice) / position.entryPrice;
    const pnlPercent = position.side === 'long' ? priceChange : -priceChange;
    const pnl = position.size * pnlPercent * position.leverage;
    const margin = position.size / position.leverage;

    player.account.balance += margin + pnl;
    player.account.closedPnl += pnl;
  });
  player.account.positions = [];
  this.updateAccountValue(player);  // Return value intentionally ignored here
  player.finalPnl = player.account.totalPnlPercent;
}
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Verify all callers of updateAccountValue compile correctly with the new signature
  </verify>
  <done>
Zero capital triggers instant battle loss, winner determined automatically, battle ends early with liquidation reason. All callers of updateAccountValue handle new boolean return appropriately.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket event for instant loss notification</name>
  <files>
    backend/src/services/battleManager.ts
    backend/src/index.ts
  </files>
  <action>
1. In battleManager.ts, emit an event before calling endBattle in endBattleByLiquidation:
```typescript
// Before calling endBattle, notify listeners of instant loss
this.emitInstantLossEvent(battleId, loserWallet, battle.winnerId || '');
```

2. Add the emit method:
```typescript
private instantLossListeners: Set<(battleId: string, loserWallet: string, winnerWallet: string) => void> = new Set();

subscribeToInstantLoss(listener: (battleId: string, loserWallet: string, winnerWallet: string) => void): () => void {
  this.instantLossListeners.add(listener);
  return () => this.instantLossListeners.delete(listener);
}

private emitInstantLossEvent(battleId: string, loserWallet: string, winnerWallet: string): void {
  this.instantLossListeners.forEach(listener => listener(battleId, loserWallet, winnerWallet));
}
```

3. In index.ts, subscribe to instant loss events and emit to battle room:
```typescript
// After battleManager import
battleManager.subscribeToInstantLoss((battleId, loserWallet, winnerWallet) => {
  io.to(`battle:${battleId}`).emit('instant_loss', {
    battleId,
    loserWallet,
    winnerWallet,
    reason: 'liquidation',
    message: `${loserWallet.slice(0, 4)}...${loserWallet.slice(-4)} was liquidated!`
  });
});
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Backend starts without errors
  </verify>
  <done>
WebSocket emits instant_loss event when battle ends due to total liquidation
  </done>
</task>

</tasks>

<verification>
- [ ] `cd backend && npm run typecheck` passes
- [ ] Backend starts without errors
- [ ] Total account value = balance + margin + unrealized PnL
- [ ] Account value <= 0 triggers instant loss
- [ ] Battle ends immediately when instant loss detected
- [ ] Winner is other player regardless of their PnL
- [ ] instant_loss WebSocket event fires with correct data
</verification>

<success_criteria>
1. Player with total account value <= 0 loses instantly
2. Battle ends early (before timer) on instant loss
3. Winner is determined even if their PnL is negative
4. Battle endReason is set to 'liquidation'
5. Chat message announces liquidation
6. WebSocket event notifies clients of instant loss
</success_criteria>

<output>
After completion, create `.planning/phases/10-battle-core/10-04-SUMMARY.md`
</output>
