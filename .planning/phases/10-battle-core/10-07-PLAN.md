---
phase: 10-battle-core
plan: 07
type: execute
wave: 3
depends_on: ["10-01", "10-02"]
files_modified:
  - web/src/app/challenges/page.tsx
  - web/src/app/battle/page.tsx
  - web/src/components/challenges/ChallengeBoard.tsx
  - web/src/components/challenges/ChallengeCard.tsx
  - web/src/components/challenges/CreateChallengeModal.tsx
  - web/src/hooks/useChallenges.ts
  - web/src/contexts/BattleContext.tsx
  - web/src/components/BattleLobby.tsx
autonomous: false

must_haves:
  truths:
    - "User can view list of open challenges on dedicated page"
    - "User can filter challenges by stake amount"
    - "User can create open or direct challenges"
    - "Challenge cards show entry fee, duration, and challenger info"
    - "Accepting a challenge initiates ready check flow"
    - "User can join matchmaking queue with stake amount from UI"
    - "/battle?challenge=CODE reads code and calls backend to accept challenge"
  artifacts:
    - path: "web/src/app/challenges/page.tsx"
      provides: "Challenge board page"
    - path: "web/src/components/challenges/ChallengeBoard.tsx"
      provides: "Challenge listing grid"
    - path: "web/src/hooks/useChallenges.ts"
      provides: "Challenge data fetching and WebSocket subscription"
  key_links:
    - from: "web/src/hooks/useChallenges.ts"
      to: "/api/challenges"
      via: "REST API fetch"
      pattern: "fetch.*api/challenges"
    - from: "web/src/hooks/useChallenges.ts"
      to: "socket"
      via: "WebSocket subscription"
      pattern: "socket.on.*challenge"
    - from: "web/src/app/battle/page.tsx"
      to: "socket.emit('accept_challenge')"
      via: "URL query param triggers challenge acceptance"
      pattern: "challenge.*searchParams.*accept_challenge"
    - from: "web/src/components/BattleLobby.tsx"
      to: "socket.emit('queue_matchmaking')"
      via: "UI stake selection triggers queue"
      pattern: "queue_matchmaking.*entryFee"
---

<objective>
Build challenge board UI for viewing and creating challenges, plus wire UI-to-backend for matchmaking and challenge acceptance

Purpose: Per CONTEXT.md, create a dedicated challenge board page where users can see open challenges and create their own. Also wire up the battle page to handle challenge codes from URL and show how matchmaking queue is joined from UI.
Output: Challenge board page, challenge card components, create challenge modal, battle page challenge handling, matchmaking wiring
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-battle-core/10-CONTEXT.md
@.planning/phases/10-battle-core/10-02-SUMMARY.md

# Source code reference
@web/src/app/battle/page.tsx
@web/src/components/BattleLobby.tsx
@web/src/contexts/BattleContext.tsx
@backend/src/db/challengesDatabase.ts
@backend/src/services/battleManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useChallenges hook</name>
  <files>
    web/src/hooks/useChallenges.ts
  </files>
  <action>
Create hook for fetching and subscribing to challenges:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { socket } from '@/lib/socket';

interface Challenge {
  id: string;
  code: string;
  challengerWallet: string;
  entryFee: number;
  duration: number;
  leverage: number;
  expiresAt: number;
  isOpen: boolean;
  targetWallet?: string;
}

interface UseChallengesOptions {
  minFee?: number;
  maxFee?: number;
  excludeWallet?: string;
  autoRefresh?: boolean;
}

export function useChallenges(options: UseChallengesOptions = {}) {
  const [challenges, setChallenges] = useState<Challenge[]>([]);
  const [directChallenges, setDirectChallenges] = useState<Challenge[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';

  const fetchChallenges = useCallback(async () => {
    try {
      setLoading(true);
      const params = new URLSearchParams();
      if (options.minFee !== undefined) params.set('minFee', options.minFee.toString());
      if (options.maxFee !== undefined) params.set('maxFee', options.maxFee.toString());
      if (options.excludeWallet) params.set('wallet', options.excludeWallet);

      const res = await fetch(`${backendUrl}/api/challenges?${params}`);
      if (!res.ok) throw new Error('Failed to fetch challenges');
      const data = await res.json();
      setChallenges(data.challenges || []);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [backendUrl, options.minFee, options.maxFee, options.excludeWallet]);

  const fetchDirectChallenges = useCallback(async (wallet: string) => {
    try {
      const res = await fetch(`${backendUrl}/api/challenges/direct/${wallet}`);
      if (!res.ok) throw new Error('Failed to fetch direct challenges');
      const data = await res.json();
      setDirectChallenges(data.challenges || []);
    } catch (err) {
      console.error('Error fetching direct challenges:', err);
    }
  }, [backendUrl]);

  const createChallenge = useCallback(async (params: {
    challengerWallet: string;
    entryFee: number;
    leverage: number;
    duration: number;
    targetWallet?: string;
  }) => {
    const res = await fetch(`${backendUrl}/api/challenges`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    });
    if (!res.ok) {
      const data = await res.json();
      throw new Error(data.error || 'Failed to create challenge');
    }
    return res.json();
  }, [backendUrl]);

  // Accept challenge via WebSocket (returns battle info for ready check)
  const acceptChallenge = useCallback((code: string, walletAddress: string): Promise<{ battleId: string }> => {
    return new Promise((resolve, reject) => {
      socket.emit('accept_challenge', { code, walletAddress });

      const handleAccepted = (data: { battleId: string }) => {
        socket.off('challenge_accepted', handleAccepted);
        socket.off('challenge_error', handleError);
        resolve(data);
      };

      const handleError = (data: { error: string }) => {
        socket.off('challenge_accepted', handleAccepted);
        socket.off('challenge_error', handleError);
        reject(new Error(data.error));
      };

      socket.on('challenge_accepted', handleAccepted);
      socket.on('challenge_error', handleError);

      // Timeout after 10 seconds
      setTimeout(() => {
        socket.off('challenge_accepted', handleAccepted);
        socket.off('challenge_error', handleError);
        reject(new Error('Challenge acceptance timed out'));
      }, 10000);
    });
  }, []);

  // Subscribe to WebSocket events
  useEffect(() => {
    socket.emit('subscribe_challenges');

    const handleNewChallenge = (data: { challenge: Challenge }) => {
      setChallenges(prev => [data.challenge, ...prev]);
    };

    const handleDirectChallenge = (data: { challenge: Challenge }) => {
      setDirectChallenges(prev => [data.challenge, ...prev]);
    };

    socket.on('challenge_created', handleNewChallenge);
    socket.on('direct_challenge_received', handleDirectChallenge);

    return () => {
      socket.emit('unsubscribe_challenges');
      socket.off('challenge_created', handleNewChallenge);
      socket.off('direct_challenge_received', handleDirectChallenge);
    };
  }, []);

  // Initial fetch
  useEffect(() => {
    fetchChallenges();
  }, [fetchChallenges]);

  // Auto-refresh every 30 seconds
  useEffect(() => {
    if (!options.autoRefresh) return;
    const interval = setInterval(fetchChallenges, 30000);
    return () => clearInterval(interval);
  }, [fetchChallenges, options.autoRefresh]);

  return {
    challenges,
    directChallenges,
    loading,
    error,
    refresh: fetchChallenges,
    fetchDirectChallenges,
    createChallenge,
    acceptChallenge,
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd web && pnpm typecheck`
  </verify>
  <done>
useChallenges hook fetches challenges, subscribes to WebSocket updates, provides createChallenge and acceptChallenge functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create challenge board components</name>
  <files>
    web/src/components/challenges/ChallengeCard.tsx
    web/src/components/challenges/ChallengeBoard.tsx
    web/src/components/challenges/CreateChallengeModal.tsx
  </files>
  <action>
1. Create ChallengeCard.tsx:
```tsx
'use client';

import { Clock, Zap, Coins, User } from 'lucide-react';

interface ChallengeCardProps {
  challenge: {
    id: string;
    code: string;
    challengerWallet: string;
    entryFee: number;
    duration: number;
    leverage: number;
    expiresAt: number;
  };
  onAccept: (code: string) => void;
  isOwnChallenge?: boolean;
}

export function ChallengeCard({ challenge, onAccept, isOwnChallenge }: ChallengeCardProps) {
  const timeRemaining = Math.max(0, Math.floor((challenge.expiresAt - Date.now()) / 1000 / 60));
  const shortWallet = `${challenge.challengerWallet.slice(0, 4)}...${challenge.challengerWallet.slice(-4)}`;

  return (
    <div className="bg-black/40 backdrop-blur border border-white/10 rounded-xl p-4 hover:border-warning/50 transition-colors">
      {/* Header */}
      <div className="flex justify-between items-start mb-3">
        <div className="flex items-center gap-2">
          <User className="w-4 h-4 text-white/40" />
          <span className="text-sm font-medium">{shortWallet}</span>
        </div>
        <span className="text-xs text-white/40 font-mono">{challenge.code}</span>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-3 gap-2 mb-4">
        <div className="text-center p-2 bg-white/5 rounded-lg">
          <Coins className="w-4 h-4 mx-auto text-warning mb-1" />
          <div className="text-lg font-bold text-warning">{challenge.entryFee}</div>
          <div className="text-[10px] text-white/40 uppercase">SOL</div>
        </div>
        <div className="text-center p-2 bg-white/5 rounded-lg">
          <Zap className="w-4 h-4 mx-auto text-purple-400 mb-1" />
          <div className="text-lg font-bold text-purple-400">{challenge.leverage}x</div>
          <div className="text-[10px] text-white/40 uppercase">Leverage</div>
        </div>
        <div className="text-center p-2 bg-white/5 rounded-lg">
          <Clock className="w-4 h-4 mx-auto text-blue-400 mb-1" />
          <div className="text-lg font-bold text-blue-400">{Math.floor(challenge.duration / 60)}</div>
          <div className="text-[10px] text-white/40 uppercase">Minutes</div>
        </div>
      </div>

      {/* Footer */}
      <div className="flex justify-between items-center">
        <span className="text-xs text-white/40">
          {timeRemaining > 60 ? `${Math.floor(timeRemaining / 60)}h` : `${timeRemaining}m`} left
        </span>
        {!isOwnChallenge ? (
          <button
            onClick={() => onAccept(challenge.code)}
            className="px-4 py-2 bg-warning text-black font-bold text-sm rounded-lg hover:bg-warning/80 transition-colors"
          >
            Accept Fight
          </button>
        ) : (
          <span className="text-xs text-white/40">Your challenge</span>
        )}
      </div>
    </div>
  );
}
```

2. Create ChallengeBoard.tsx:
```tsx
'use client';

import { useState } from 'react';
import { ChallengeCard } from './ChallengeCard';
import { Plus, Filter } from 'lucide-react';

interface Challenge {
  id: string;
  code: string;
  challengerWallet: string;
  entryFee: number;
  duration: number;
  leverage: number;
  expiresAt: number;
}

interface ChallengeBoardProps {
  challenges: Challenge[];
  currentWallet?: string;
  onAccept: (code: string) => void;
  onCreateChallenge: () => void;
  loading?: boolean;
}

const STAKE_FILTERS = [
  { label: 'All', min: undefined, max: undefined },
  { label: '< 0.1 SOL', min: undefined, max: 0.1 },
  { label: '0.1 - 0.5 SOL', min: 0.1, max: 0.5 },
  { label: '0.5 - 1 SOL', min: 0.5, max: 1 },
  { label: '> 1 SOL', min: 1, max: undefined },
];

export function ChallengeBoard({
  challenges,
  currentWallet,
  onAccept,
  onCreateChallenge,
  loading,
}: ChallengeBoardProps) {
  const [stakeFilter, setStakeFilter] = useState(0);

  const filteredChallenges = challenges.filter(c => {
    const filter = STAKE_FILTERS[stakeFilter];
    if (filter.min !== undefined && c.entryFee < filter.min) return false;
    if (filter.max !== undefined && c.entryFee > filter.max) return false;
    return true;
  });

  return (
    <div>
      {/* Header */}
      <div className="flex justify-between items-center mb-6">
        <div>
          <h2 className="text-2xl font-black text-white">Challenge Board</h2>
          <p className="text-sm text-white/40">Accept a fight or create your own</p>
        </div>
        <button
          onClick={onCreateChallenge}
          className="flex items-center gap-2 px-4 py-2 bg-warning text-black font-bold rounded-lg hover:bg-warning/80 transition-colors"
        >
          <Plus className="w-4 h-4" />
          Create Challenge
        </button>
      </div>

      {/* Filters */}
      <div className="flex items-center gap-2 mb-4">
        <Filter className="w-4 h-4 text-white/40" />
        <div className="flex gap-2">
          {STAKE_FILTERS.map((filter, idx) => (
            <button
              key={filter.label}
              onClick={() => setStakeFilter(idx)}
              className={`px-3 py-1 text-xs rounded-full transition-colors ${
                stakeFilter === idx
                  ? 'bg-warning text-black font-bold'
                  : 'bg-white/10 text-white/60 hover:bg-white/20'
              }`}
            >
              {filter.label}
            </button>
          ))}
        </div>
      </div>

      {/* Grid */}
      {loading ? (
        <div className="text-center py-12 text-white/40">Loading challenges...</div>
      ) : filteredChallenges.length === 0 ? (
        <div className="text-center py-12">
          <p className="text-white/40 mb-4">No open challenges</p>
          <button
            onClick={onCreateChallenge}
            className="px-4 py-2 bg-white/10 text-white font-medium rounded-lg hover:bg-white/20 transition-colors"
          >
            Be the first to create one
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredChallenges.map(challenge => (
            <ChallengeCard
              key={challenge.id}
              challenge={challenge}
              onAccept={onAccept}
              isOwnChallenge={currentWallet === challenge.challengerWallet}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

3. Create CreateChallengeModal.tsx:
```tsx
'use client';

import { useState } from 'react';
import { X, Zap, Clock, Coins, Target } from 'lucide-react';

interface CreateChallengeModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreate: (params: {
    entryFee: number;
    leverage: number;
    duration: number;
    targetWallet?: string;
  }) => Promise<void>;
}

const ENTRY_FEES = [0.01, 0.05, 0.1, 0.5, 1];
const LEVERAGES = [2, 5, 10, 20];
const DURATIONS = [60, 180, 300]; // seconds

export function CreateChallengeModal({ isOpen, onClose, onCreate }: CreateChallengeModalProps) {
  const [entryFee, setEntryFee] = useState(0.1);
  const [leverage, setLeverage] = useState(5);
  const [duration, setDuration] = useState(180);
  const [targetWallet, setTargetWallet] = useState('');
  const [isDirectChallenge, setIsDirectChallenge] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  if (!isOpen) return null;

  const handleCreate = async () => {
    setLoading(true);
    setError('');
    try {
      await onCreate({
        entryFee,
        leverage,
        duration,
        targetWallet: isDirectChallenge && targetWallet ? targetWallet : undefined,
      });
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create challenge');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur">
      <div className="w-full max-w-md bg-[#0d0d0d] border border-white/10 rounded-2xl p-6">
        {/* Header */}
        <div className="flex justify-between items-center mb-6">
          <h3 className="text-xl font-black text-white">Create Challenge</h3>
          <button onClick={onClose} className="text-white/40 hover:text-white">
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Entry Fee */}
        <div className="mb-4">
          <label className="flex items-center gap-2 text-sm text-white/60 mb-2">
            <Coins className="w-4 h-4" /> Entry Fee (SOL)
          </label>
          <div className="flex gap-2">
            {ENTRY_FEES.map(fee => (
              <button
                key={fee}
                onClick={() => setEntryFee(fee)}
                className={`flex-1 py-2 rounded-lg text-sm font-bold transition-colors ${
                  entryFee === fee
                    ? 'bg-warning text-black'
                    : 'bg-white/10 text-white hover:bg-white/20'
                }`}
              >
                {fee}
              </button>
            ))}
          </div>
        </div>

        {/* Leverage */}
        <div className="mb-4">
          <label className="flex items-center gap-2 text-sm text-white/60 mb-2">
            <Zap className="w-4 h-4" /> Leverage
          </label>
          <div className="flex gap-2">
            {LEVERAGES.map(lev => (
              <button
                key={lev}
                onClick={() => setLeverage(lev)}
                className={`flex-1 py-2 rounded-lg text-sm font-bold transition-colors ${
                  leverage === lev
                    ? 'bg-purple-500 text-white'
                    : 'bg-white/10 text-white hover:bg-white/20'
                }`}
              >
                {lev}x
              </button>
            ))}
          </div>
        </div>

        {/* Duration */}
        <div className="mb-4">
          <label className="flex items-center gap-2 text-sm text-white/60 mb-2">
            <Clock className="w-4 h-4" /> Duration
          </label>
          <div className="flex gap-2">
            {DURATIONS.map(dur => (
              <button
                key={dur}
                onClick={() => setDuration(dur)}
                className={`flex-1 py-2 rounded-lg text-sm font-bold transition-colors ${
                  duration === dur
                    ? 'bg-blue-500 text-white'
                    : 'bg-white/10 text-white hover:bg-white/20'
                }`}
              >
                {dur / 60}m
              </button>
            ))}
          </div>
        </div>

        {/* Direct Challenge Toggle */}
        <div className="mb-4">
          <label className="flex items-center gap-3 cursor-pointer">
            <input
              type="checkbox"
              checked={isDirectChallenge}
              onChange={e => setIsDirectChallenge(e.target.checked)}
              className="w-4 h-4 rounded border-white/20"
            />
            <span className="text-sm text-white/60">Direct challenge specific wallet</span>
          </label>
        </div>

        {/* Target Wallet Input */}
        {isDirectChallenge && (
          <div className="mb-4">
            <label className="flex items-center gap-2 text-sm text-white/60 mb-2">
              <Target className="w-4 h-4" /> Target Wallet Address
            </label>
            <input
              type="text"
              value={targetWallet}
              onChange={e => setTargetWallet(e.target.value)}
              placeholder="Enter wallet address..."
              className="w-full px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder:text-white/30 focus:border-warning focus:outline-none"
            />
          </div>
        )}

        {/* Error */}
        {error && (
          <div className="mb-4 p-3 bg-danger/20 border border-danger/40 rounded-lg text-danger text-sm">
            {error}
          </div>
        )}

        {/* Create Button */}
        <button
          onClick={handleCreate}
          disabled={loading}
          className="w-full py-3 bg-warning text-black font-bold rounded-lg hover:bg-warning/80 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Creating...' : 'Create Challenge'}
        </button>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
TypeScript compiles: `cd web && pnpm typecheck`
  </verify>
  <done>
ChallengeCard, ChallengeBoard, and CreateChallengeModal components created with proper styling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create challenges page and wire battle page challenge acceptance</name>
  <files>
    web/src/app/challenges/page.tsx
    web/src/app/battle/page.tsx
  </files>
  <action>
1. Create the challenges page (web/src/app/challenges/page.tsx):

```tsx
'use client';

import { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useRouter } from 'next/navigation';
import { ChallengeBoard } from '@/components/challenges/ChallengeBoard';
import { CreateChallengeModal } from '@/components/challenges/CreateChallengeModal';
import { useChallenges } from '@/hooks/useChallenges';
import { Swords, Bell } from 'lucide-react';

export default function ChallengesPage() {
  const { publicKey, connected } = useWallet();
  const router = useRouter();
  const wallet = publicKey?.toBase58();

  const { challenges, directChallenges, loading, createChallenge, fetchDirectChallenges } = useChallenges({
    excludeWallet: wallet,
    autoRefresh: true,
  });

  const [showCreateModal, setShowCreateModal] = useState(false);

  // Fetch direct challenges when wallet connects
  useState(() => {
    if (wallet) {
      fetchDirectChallenges(wallet);
    }
  });

  const handleAccept = async (code: string) => {
    if (!connected) {
      alert('Please connect your wallet');
      return;
    }
    // Navigate to battle page with challenge code - battle page handles the actual acceptance
    router.push(`/battle?challenge=${code}`);
  };

  const handleCreateChallenge = async (params: {
    entryFee: number;
    leverage: number;
    duration: number;
    targetWallet?: string;
  }) => {
    if (!wallet) throw new Error('Wallet not connected');
    await createChallenge({
      challengerWallet: wallet,
      ...params,
    });
  };

  return (
    <div className="min-h-screen bg-primary py-8 px-4">
      <div className="max-w-6xl mx-auto">
        {/* Page Header */}
        <div className="flex items-center gap-4 mb-8">
          <Swords className="w-10 h-10 text-warning" />
          <div>
            <h1 className="text-3xl font-black text-white">Fight Board</h1>
            <p className="text-white/60">Find an opponent or throw down a challenge</p>
          </div>
        </div>

        {/* Direct Challenges Alert */}
        {directChallenges.length > 0 && (
          <div className="mb-6 p-4 bg-warning/10 border border-warning/40 rounded-xl">
            <div className="flex items-center gap-3">
              <Bell className="w-5 h-5 text-warning" />
              <div>
                <h3 className="font-bold text-warning">
                  You have {directChallenges.length} direct challenge{directChallenges.length > 1 ? 's' : ''}!
                </h3>
                <p className="text-sm text-white/60">Someone wants to fight you specifically</p>
              </div>
            </div>
            <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
              {directChallenges.slice(0, 2).map(c => (
                <button
                  key={c.id}
                  onClick={() => handleAccept(c.code)}
                  className="flex justify-between items-center p-3 bg-black/40 rounded-lg hover:bg-black/60 transition-colors"
                >
                  <span className="text-sm">{c.entryFee} SOL • {c.leverage}x • {Math.floor(c.duration / 60)}m</span>
                  <span className="text-xs text-warning font-bold">Accept →</span>
                </button>
              ))}
            </div>
          </div>
        )}

        {/* Challenge Board */}
        <ChallengeBoard
          challenges={challenges}
          currentWallet={wallet}
          onAccept={handleAccept}
          onCreateChallenge={() => setShowCreateModal(true)}
          loading={loading}
        />

        {/* Create Modal */}
        <CreateChallengeModal
          isOpen={showCreateModal}
          onClose={() => setShowCreateModal(false)}
          onCreate={handleCreateChallenge}
        />
      </div>
    </div>
  );
}
```

2. Update battle page (web/src/app/battle/page.tsx) to handle challenge code from URL:

Add useSearchParams and challenge acceptance logic:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useSearchParams } from 'next/navigation';
import { BattleProvider, useBattleContext } from '@/contexts/BattleContext';
import { BattleLobby } from '@/components/BattleLobby';
import { BattleArena } from '@/components/BattleArena';
import { PageLoading } from '@/components/ui/skeleton';
import { PageErrorBoundary } from '@/components/error-boundaries/PageErrorBoundary';
import { NextMatchBanner, UpcomingMatches } from '@/components/UpcomingMatches';
import { useChallenges } from '@/hooks/useChallenges';
import { socket } from '@/lib/socket';

function BattleContent() {
  const { battle } = useBattleContext();
  const { connected, publicKey } = useWallet();
  const searchParams = useSearchParams();
  const challengeCode = searchParams.get('challenge');
  const wallet = publicKey?.toBase58();

  const { acceptChallenge } = useChallenges();
  const [acceptingChallenge, setAcceptingChallenge] = useState(false);
  const [challengeError, setChallengeError] = useState<string | null>(null);

  // Handle challenge code from URL query param
  useEffect(() => {
    if (challengeCode && wallet && connected && !acceptingChallenge && !battle) {
      setAcceptingChallenge(true);
      setChallengeError(null);

      console.log(`[BattlePage] Accepting challenge with code: ${challengeCode}`);

      acceptChallenge(challengeCode, wallet)
        .then((result) => {
          console.log(`[BattlePage] Challenge accepted, battle ID: ${result.battleId}`);
          // The battle context will pick up the new battle via WebSocket
          // Clear the URL param to prevent re-acceptance on refresh
          window.history.replaceState({}, '', '/battle');
        })
        .catch((err) => {
          console.error('[BattlePage] Failed to accept challenge:', err);
          setChallengeError(err.message || 'Failed to accept challenge');
        })
        .finally(() => {
          setAcceptingChallenge(false);
        });
    }
  }, [challengeCode, wallet, connected, acceptChallenge, acceptingChallenge, battle]);

  console.log('[BattlePage] Rendering, battle:', battle?.id, 'status:', battle?.status);

  // Show loading state while accepting challenge
  if (acceptingChallenge) {
    return (
      <div className="flex flex-col items-center justify-center py-20">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-warning mb-4" />
        <p className="text-white/60">Accepting challenge...</p>
      </div>
    );
  }

  // Show error if challenge acceptance failed
  if (challengeError) {
    return (
      <div className="flex flex-col items-center justify-center py-20">
        <div className="bg-danger/20 border border-danger/40 rounded-xl p-6 max-w-md text-center">
          <p className="text-danger font-bold mb-2">Challenge Error</p>
          <p className="text-white/60 mb-4">{challengeError}</p>
          <button
            onClick={() => {
              setChallengeError(null);
              window.history.replaceState({}, '', '/battle');
            }}
            className="px-4 py-2 bg-white/10 text-white rounded-lg hover:bg-white/20"
          >
            Back to Lobby
          </button>
        </div>
      </div>
    );
  }

  // If in an active or completed battle, show the arena
  if (battle && (battle.status === 'active' || battle.status === 'completed')) {
    console.log('[BattlePage] Showing BattleArena');
    return <BattleArena battle={battle} />;
  }

  // Otherwise show lobby with scheduled matches (when connected)
  console.log('[BattlePage] Showing BattleLobby');
  return (
    <div className="space-y-8">
      {/* Scheduled matches section - only show when wallet connected */}
      {connected && (
        <section id="scheduled">
          <h2 className="text-2xl font-bold mb-4 text-warning">Scheduled Battles</h2>
          <p className="text-gray-400 mb-4">
            Join a scheduled match for guaranteed opponents. Registration opens 30 minutes before each battle.
          </p>
          <UpcomingMatches limit={3} showHeader={false} />
        </section>
      )}

      {/* Divider - only when showing scheduled section */}
      {connected && (
        <div className="border-t border-white/10" />
      )}

      {/* Instant matchmaking section */}
      <section>
        {connected && (
          <>
            <h2 className="text-2xl font-bold mb-4">Quick Match</h2>
            <p className="text-gray-400 mb-4">
              Find an opponent now with instant matchmaking.
            </p>
          </>
        )}
        <BattleLobby />
      </section>
    </div>
  );
}

function BattleWithWallet() {
  const { publicKey, signMessage } = useWallet();
  const walletAddress = publicKey?.toBase58() || null;

  return (
    <BattleProvider walletAddress={walletAddress} signMessage={signMessage}>
      <BattleContent />
    </BattleProvider>
  );
}

export default function BattlePage() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <PageLoading message="Entering the Arena..." />;
  }

  return (
    <PageErrorBoundary pageName="Battle Arena">
      <div className="w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 overflow-x-hidden">
        <NextMatchBanner />
        <BattleWithWallet />
      </div>
    </PageErrorBoundary>
  );
}
```
  </action>
  <verify>
TypeScript compiles: `cd web && pnpm typecheck`
Build succeeds: `cd web && pnpm build`
  </verify>
  <done>
/challenges page shows challenge board, /battle page reads ?challenge=CODE from URL and calls acceptChallenge to start battle via WebSocket
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire matchmaking queue from BattleLobby UI</name>
  <files>
    web/src/components/BattleLobby.tsx
  </files>
  <action>
Update BattleLobby.tsx to explicitly show how stake amount from UI is passed to battleManager.queueForMatchmaking:

The BattleLobby component should have:
1. Stake amount selection UI (entry fee buttons like 0.01, 0.1, 0.5, 1 SOL)
2. Duration selection (1min, 3min, 5min)
3. "Find Match" button that emits queue_matchmaking with the selected config

Ensure the component includes this wiring pattern:

```tsx
// Inside BattleLobby component
const [entryFee, setEntryFee] = useState(0.1);  // Default stake
const [duration, setDuration] = useState(180);   // Default 3 min

const handleFindMatch = () => {
  if (!connected || !wallet) {
    // Show connect wallet prompt
    return;
  }

  // Emit queue_matchmaking with stake amount from UI
  // This calls battleManager.queueForMatchmaking on backend
  socket.emit('queue_matchmaking', {
    config: {
      entryFee,           // Stake amount selected by user
      duration,           // Battle duration selected by user
      mode: 'real',       // Real money mode
      maxPlayers: 2,      // 1v1 battle
    },
    walletAddress: wallet,
  });

  setIsSearching(true);
};

// Entry fee selection buttons
const ENTRY_FEES = [0.01, 0.05, 0.1, 0.5, 1];

// In JSX:
<div className="flex gap-2">
  {ENTRY_FEES.map(fee => (
    <button
      key={fee}
      onClick={() => setEntryFee(fee)}
      className={`px-4 py-2 rounded-lg ${entryFee === fee ? 'bg-warning text-black' : 'bg-white/10'}`}
    >
      {fee} SOL
    </button>
  ))}
</div>

<button
  onClick={handleFindMatch}
  disabled={!connected || isSearching}
  className="w-full py-3 bg-warning text-black font-bold rounded-lg"
>
  {isSearching ? 'Searching...' : 'Find Match'}
</button>
```

The key wiring is: User selects stake (entryFee) in UI → socket.emit('queue_matchmaking', { config: { entryFee, ... } }) → backend battleManager.queueForMatchmaking(config, wallet)

If BattleLobby already has this pattern, verify it exists and document it. If missing, add the stake selection and queue emission.
  </action>
  <verify>
TypeScript compiles: `cd web && pnpm typecheck`
Verify socket.emit('queue_matchmaking') is called with entryFee from UI state
  </verify>
  <done>
BattleLobby UI passes user-selected stake amount to battleManager.queueForMatchmaking via socket.emit('queue_matchmaking', { config: { entryFee } })
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Challenge board page with listing, filtering, creation, direct challenges, and full matchmaking/challenge acceptance wiring</what-built>
  <how-to-verify>
1. Start backend: `cd backend && npm run dev`
2. Start frontend: `cd web && pnpm dev`
3. Navigate to http://localhost:3000/challenges
4. Verify:
   - Challenge board displays (may be empty initially)
   - "Create Challenge" button opens modal
   - Modal shows entry fee, leverage, duration options
   - Direct challenge checkbox reveals wallet input
   - Stake filters work (All, < 0.1 SOL, etc.)
5. If wallet connected, verify user's own challenges show "Your challenge" instead of accept button
6. Navigate to http://localhost:3000/battle
7. Verify stake selection buttons and "Find Match" triggers queue
8. Test challenge acceptance: Navigate to /battle?challenge=TESTCODE (will error but should show acceptance flow)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] `cd web && pnpm typecheck` passes
- [ ] `cd web && pnpm build` succeeds
- [ ] /challenges page loads without errors
- [ ] Challenge board displays challenges from API
- [ ] Stake filters work correctly
- [ ] Create challenge modal opens and closes
- [ ] Challenge creation calls API successfully
- [ ] Direct challenges show in alert banner
- [ ] /battle?challenge=CODE triggers acceptChallenge flow
- [ ] BattleLobby stake selection wires to queue_matchmaking
</verification>

<success_criteria>
1. Challenge board page shows all open challenges
2. Challenges can be filtered by stake amount
3. Create challenge modal allows setting fee, leverage, duration
4. Direct challenge option allows targeting specific wallet
5. Accepting challenge navigates to battle page with code
6. /battle page reads challenge query param and calls backend acceptChallenge
7. Direct challenges appear in prominent alert banner
8. Real-time updates via WebSocket when new challenges created
9. BattleLobby UI shows how stake amount flows to queue_matchmaking
</success_criteria>

<output>
After completion, create `.planning/phases/10-battle-core/10-07-SUMMARY.md`
</output>
