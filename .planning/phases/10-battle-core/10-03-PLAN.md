---
phase: 10-battle-core
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/battleHistoryDatabase.ts
  - backend/src/services/battleManager.ts
  - backend/src/index.ts
  - backend/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Battle history is persisted to database after battle ends"
    - "User can retrieve their battle history via API"
    - "Battle history includes opponent, result, PnL, and entry fee"
    - "Tie battles (price unchanged) are handled gracefully"
  artifacts:
    - path: "backend/src/db/battleHistoryDatabase.ts"
      provides: "Battle history storage and queries"
      exports: ["saveBattleResult", "getBattleHistory", "getBattleById"]
  key_links:
    - from: "backend/src/services/battleManager.ts"
      to: "battleHistoryDatabase.saveBattleResult"
      via: "endBattle() persists result"
      pattern: "saveBattleResult"
    - from: "backend/src/index.ts"
      to: "battleHistoryDatabase.getBattleHistory"
      via: "GET /api/battles/history/:wallet"
      pattern: "getBattleHistory"
---

<objective>
Create battle history database for persistent battle records

Purpose: Store completed battle results for fighter profiles, statistics, and historical lookup. Also implement tie handling for edge case when price doesn't change.
Output: Battle history database, API endpoints, tie handling in settlement
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-battle-core/10-RESEARCH.md

# Source code for extension
@backend/src/services/battleManager.ts
@backend/src/db/progressionDatabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create battle history database</name>
  <files>
    backend/src/db/battleHistoryDatabase.ts
    backend/src/types.ts
  </files>
  <action>
Create battleHistoryDatabase.ts following progressionDatabase.ts patterns:

```typescript
import Database from 'better-sqlite3';
import path from 'path';
import fs from 'fs';

const dataDir = path.join(__dirname, '../../data');
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir, { recursive: true });
}

const db = new Database(path.join(dataDir, 'battle_history.db'));

export interface BattleHistoryRecord {
  id: string;
  battleId: string;
  player1Wallet: string;
  player2Wallet: string;
  winnerWallet: string | null;  // null if tie
  player1PnlPercent: number;
  player2PnlPercent: number;
  entryFee: number;
  prizePool: number;
  duration: number;
  isTie: boolean;
  startedAt: number;
  endedAt: number;
  createdAt: number;
}

export interface PlayerBattleHistory {
  battleId: string;
  opponentWallet: string;
  result: 'win' | 'loss' | 'tie';
  myPnlPercent: number;
  opponentPnlPercent: number;
  entryFee: number;
  payout: number;  // 0 for loss, half for tie, full prize for win
  duration: number;
  endedAt: number;
}

export function initializeBattleHistoryDatabase(): void {
  db.exec(`
    CREATE TABLE IF NOT EXISTS battle_history (
      id TEXT PRIMARY KEY,
      battle_id TEXT UNIQUE NOT NULL,
      player1_wallet TEXT NOT NULL,
      player2_wallet TEXT NOT NULL,
      winner_wallet TEXT,
      player1_pnl_percent REAL NOT NULL,
      player2_pnl_percent REAL NOT NULL,
      entry_fee REAL NOT NULL,
      prize_pool REAL NOT NULL,
      duration INTEGER NOT NULL,
      is_tie INTEGER DEFAULT 0,
      started_at INTEGER NOT NULL,
      ended_at INTEGER NOT NULL,
      created_at INTEGER NOT NULL
    );

    CREATE INDEX IF NOT EXISTS idx_battle_history_player1 ON battle_history(player1_wallet);
    CREATE INDEX IF NOT EXISTS idx_battle_history_player2 ON battle_history(player2_wallet);
    CREATE INDEX IF NOT EXISTS idx_battle_history_ended ON battle_history(ended_at);
  `);

  console.log('[BattleHistoryDB] Database initialized');
}

export function saveBattleResult(record: Omit<BattleHistoryRecord, 'id' | 'createdAt'>): BattleHistoryRecord {
  const id = require('uuid').v4();
  const createdAt = Date.now();

  const stmt = db.prepare(`
    INSERT INTO battle_history (
      id, battle_id, player1_wallet, player2_wallet, winner_wallet,
      player1_pnl_percent, player2_pnl_percent, entry_fee, prize_pool,
      duration, is_tie, started_at, ended_at, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    id,
    record.battleId,
    record.player1Wallet,
    record.player2Wallet,
    record.winnerWallet,
    record.player1PnlPercent,
    record.player2PnlPercent,
    record.entryFee,
    record.prizePool,
    record.duration,
    record.isTie ? 1 : 0,
    record.startedAt,
    record.endedAt,
    createdAt
  );

  return { ...record, id, createdAt };
}

export function getBattleHistory(walletAddress: string, limit: number = 20): PlayerBattleHistory[] {
  const stmt = db.prepare(`
    SELECT * FROM battle_history
    WHERE player1_wallet = ? OR player2_wallet = ?
    ORDER BY ended_at DESC
    LIMIT ?
  `);

  const rows = stmt.all(walletAddress, walletAddress, limit) as any[];

  return rows.map(row => {
    const isPlayer1 = row.player1_wallet === walletAddress;
    const myPnl = isPlayer1 ? row.player1_pnl_percent : row.player2_pnl_percent;
    const oppPnl = isPlayer1 ? row.player2_pnl_percent : row.player1_pnl_percent;
    const opponentWallet = isPlayer1 ? row.player2_wallet : row.player1_wallet;

    let result: 'win' | 'loss' | 'tie';
    let payout: number;
    const prizeAfterRake = row.prize_pool * 0.95;

    if (row.is_tie) {
      result = 'tie';
      payout = row.entry_fee;  // Get entry fee back on tie
    } else if (row.winner_wallet === walletAddress) {
      result = 'win';
      payout = prizeAfterRake;
    } else {
      result = 'loss';
      payout = 0;
    }

    return {
      battleId: row.battle_id,
      opponentWallet,
      result,
      myPnlPercent: myPnl,
      opponentPnlPercent: oppPnl,
      entryFee: row.entry_fee,
      payout,
      duration: row.duration,
      endedAt: row.ended_at,
    };
  });
}

export function getBattleById(battleId: string): BattleHistoryRecord | null {
  const stmt = db.prepare('SELECT * FROM battle_history WHERE battle_id = ?');
  const row = stmt.get(battleId) as any;
  if (!row) return null;

  return {
    id: row.id,
    battleId: row.battle_id,
    player1Wallet: row.player1_wallet,
    player2Wallet: row.player2_wallet,
    winnerWallet: row.winner_wallet,
    player1PnlPercent: row.player1_pnl_percent,
    player2PnlPercent: row.player2_pnl_percent,
    entryFee: row.entry_fee,
    prizePool: row.prize_pool,
    duration: row.duration,
    isTie: !!row.is_tie,
    startedAt: row.started_at,
    endedAt: row.ended_at,
    createdAt: row.created_at,
  };
}

export function getPlayerStats(walletAddress: string): {
  totalBattles: number;
  wins: number;
  losses: number;
  ties: number;
  winRate: number;
} {
  const stmt = db.prepare(`
    SELECT
      COUNT(*) as total,
      SUM(CASE WHEN winner_wallet = ? THEN 1 ELSE 0 END) as wins,
      SUM(CASE WHEN is_tie = 1 THEN 1 ELSE 0 END) as ties,
      SUM(CASE WHEN winner_wallet IS NOT NULL AND winner_wallet != ? AND is_tie = 0 THEN 1 ELSE 0 END) as losses
    FROM battle_history
    WHERE player1_wallet = ? OR player2_wallet = ?
  `);

  const row = stmt.get(walletAddress, walletAddress, walletAddress, walletAddress) as any;

  const total = row.total || 0;
  const wins = row.wins || 0;

  return {
    totalBattles: total,
    wins,
    losses: row.losses || 0,
    ties: row.ties || 0,
    winRate: total > 0 ? (wins / total) * 100 : 0,
  };
}

// Initialize on import
initializeBattleHistoryDatabase();
```

Add types to types.ts if not already exported from the database file.
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
  </verify>
  <done>
Battle history database created with saveBattleResult, getBattleHistory, getBattleById, getPlayerStats
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tie handling and history persistence to battleManager</name>
  <files>
    backend/src/services/battleManager.ts
  </files>
  <action>
Modify endBattle() in battleManager.ts:

1. Import battleHistoryDatabase:
```typescript
import * as battleHistoryDb from '../db/battleHistoryDatabase';
```

2. Add tie detection after PnL calculation:
```typescript
// After sorting by PnL and assigning ranks
const sorted = [...battle.players].sort((a, b) => (b.finalPnl || 0) - (a.finalPnl || 0));

// Check for tie (both players have same PnL, or both are effectively 0)
const player1Pnl = sorted[0]?.finalPnl || 0;
const player2Pnl = sorted[1]?.finalPnl || 0;
const isTie = Math.abs(player1Pnl - player2Pnl) < 0.01;  // Less than 0.01% difference = tie

if (isTie) {
  // Tie handling: both players get their entry fee back
  battle.winnerId = undefined;  // No winner
  console.log(`Battle ${battleId} ended in a TIE! Both players at ~${player1Pnl.toFixed(2)}%`);

  // Refund both players their entry fee (not the whole prize pool)
  for (const player of battle.players) {
    if (!player.isFreeBet) {
      const refundLamports = Math.floor(battle.config.entryFee * LAMPORTS_PER_SOL);
      try {
        await balanceService.creditWinnings(
          player.walletAddress,
          refundLamports,
          'battle',
          battleId
        );
        console.log(`[Battle] Tie refund ${refundLamports / LAMPORTS_PER_SOL} SOL to ${player.walletAddress}`);
      } catch (error) {
        console.error(`[Battle] Failed to refund tie to ${player.walletAddress}:`, error);
      }
    }
  }
} else {
  // Normal winner logic (existing code)
  sorted.forEach((player, index) => {
    player.rank = index + 1;
  });
  battle.winnerId = sorted[0]?.walletAddress;
  // ... existing winner payout code ...
}
```

3. Add history persistence after settlement:
```typescript
// After settlement (both tie and winner cases)
if (battle.players.length === 2 && battle.startedAt) {
  try {
    battleHistoryDb.saveBattleResult({
      battleId: battle.id,
      player1Wallet: battle.players[0].walletAddress,
      player2Wallet: battle.players[1].walletAddress,
      winnerWallet: battle.winnerId || null,
      player1PnlPercent: battle.players[0].finalPnl || 0,
      player2PnlPercent: battle.players[1].finalPnl || 0,
      entryFee: battle.config.entryFee,
      prizePool: battle.prizePool,
      duration: battle.config.duration,
      isTie,
      startedAt: battle.startedAt,
      endedAt: battle.endedAt || Date.now(),
    });
    console.log(`[Battle] History saved for ${battle.id}`);
  } catch (error) {
    console.error(`[Battle] Failed to save history:`, error);
  }
}
```

4. Update userStatsDb.recordWager for ties:
```typescript
battle.players.forEach(player => {
  const isWinner = player.walletAddress === battle.winnerId;
  const outcome = isTie ? 'push' : (isWinner ? 'won' : 'lost');
  const profitLoss = isTie ? 0 : (isWinner ? (prizeAfterRake - entryFee) : -entryFee);

  try {
    userStatsDb.recordWager(
      player.walletAddress,
      'battle',
      entryFee,
      outcome,
      profitLoss,
      battleId
    );
  } catch (error) {
    console.error(`[Battle] Failed to record wager for ${player.walletAddress}:`, error);
  }
});
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
  </verify>
  <done>
Battle history is saved after every battle, tie handling refunds both players their entry fee
  </done>
</task>

<task type="auto">
  <name>Task 3: Add battle history API endpoints</name>
  <files>
    backend/src/index.ts
  </files>
  <action>
Add REST endpoints for battle history:

```typescript
import * as battleHistoryDb from './db/battleHistoryDatabase';

// GET /api/battles/history/:wallet - Get player's battle history
app.get('/api/battles/history/:wallet', (req, res) => {
  try {
    const limit = parseInt(req.query.limit as string) || 20;
    const history = battleHistoryDb.getBattleHistory(req.params.wallet, Math.min(limit, 100));
    res.json({ history });
  } catch (error) {
    console.error('[API] Error fetching battle history:', error);
    res.status(500).json({ error: 'Failed to fetch battle history' });
  }
});

// GET /api/battles/stats/:wallet - Get player's battle stats
app.get('/api/battles/stats/:wallet', (req, res) => {
  try {
    const stats = battleHistoryDb.getPlayerStats(req.params.wallet);
    res.json(stats);
  } catch (error) {
    console.error('[API] Error fetching battle stats:', error);
    res.status(500).json({ error: 'Failed to fetch battle stats' });
  }
});

// GET /api/battles/record/:battleId - Get specific battle record
app.get('/api/battles/record/:battleId', (req, res) => {
  try {
    const record = battleHistoryDb.getBattleById(req.params.battleId);
    if (!record) {
      return res.status(404).json({ error: 'Battle not found' });
    }
    res.json({ record });
  } catch (error) {
    console.error('[API] Error fetching battle record:', error);
    res.status(500).json({ error: 'Failed to fetch battle record' });
  }
});
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Backend starts without errors
Test: `curl http://localhost:3001/api/battles/stats/test-wallet` returns stats JSON
  </verify>
  <done>
API endpoints return battle history, player stats, and individual battle records
  </done>
</task>

</tasks>

<verification>
- [ ] `cd backend && npm run typecheck` passes
- [ ] Backend starts without errors
- [ ] battle_history.db created in data directory
- [ ] GET /api/battles/history/:wallet returns array
- [ ] GET /api/battles/stats/:wallet returns totalBattles, wins, losses, ties, winRate
- [ ] Tie detection threshold is 0.01% PnL difference
</verification>

<success_criteria>
1. Battle history persists to SQLite after every battle
2. Tie battles (PnL difference < 0.01%) refund both players
3. Tie battles record correctly with isTie=true, winnerWallet=null
4. API returns battle history for any wallet
5. Player stats aggregate wins/losses/ties correctly
6. Win rate calculated correctly (wins / totalBattles)
</success_criteria>

<output>
After completion, create `.planning/phases/10-battle-core/10-03-SUMMARY.md`
</output>
