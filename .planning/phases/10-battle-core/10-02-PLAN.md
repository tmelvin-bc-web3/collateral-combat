---
phase: 10-battle-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/challengesDatabase.ts
  - backend/src/index.ts
  - backend/src/services/battleManager.ts
autonomous: true

must_haves:
  truths:
    - "User can see list of open challenges available to accept"
    - "User can create challenge targeting specific wallet (direct challenge)"
    - "Challenges are filterable by stake amount"
    - "Only valid pending challenges are shown (not expired)"
  artifacts:
    - path: "backend/src/db/challengesDatabase.ts"
      provides: "Open challenges query and direct challenge support"
      exports: ["getOpenChallenges", "createChallenge"]
    - path: "backend/src/index.ts"
      provides: "REST endpoint for challenges"
      contains: "/api/challenges"
  key_links:
    - from: "backend/src/index.ts"
      to: "challengesDatabase.getOpenChallenges"
      via: "GET /api/challenges endpoint"
      pattern: "getOpenChallenges"
    - from: "backend/src/services/battleManager.ts"
      to: "challengesDatabase"
      via: "Challenge acceptance creates battle"
      pattern: "acceptChallenge"
---

<objective>
Enhance challenge system with open listing and direct wallet challenges

Purpose: Enable challenge board where players can see and accept open challenges, plus ability to directly challenge a specific opponent by wallet address.
Output: Open challenges API endpoint, direct challenge support, challenge filtering
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-battle-core/10-RESEARCH.md

# Source code for extension
@backend/src/db/challengesDatabase.ts
@backend/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add open challenges query and direct challenge support</name>
  <files>
    backend/src/db/challengesDatabase.ts
  </files>
  <action>
Extend challengesDatabase.ts:

1. Add column for direct challenges in schema (run migration):
```typescript
// In initializeChallengesDatabase, add ALTER TABLE if column doesn't exist:
try {
  db.exec(`ALTER TABLE battle_challenges ADD COLUMN target_wallet TEXT`);
} catch (e) {
  // Column already exists, ignore
}
```

2. Update BattleChallenge interface:
```typescript
export interface BattleChallenge {
  // ... existing fields ...
  targetWallet?: string;  // For direct challenges
  isOpen: boolean;        // true if no target wallet (open to anyone)
}
```

3. Update createChallenge to accept optional targetWallet:
```typescript
export function createChallenge(params: {
  challengerWallet: string;
  challengerUsername?: string;
  entryFee: number;
  leverage: number;
  duration: number;
  targetWallet?: string;  // NEW: optional direct challenge target
}): BattleChallenge
```
Update INSERT to include target_wallet column.

4. Add getOpenChallenges function:
```typescript
export function getOpenChallenges(filters?: {
  minFee?: number;
  maxFee?: number;
  excludeWallet?: string;  // Don't show user's own challenges
}): BattleChallenge[] {
  let sql = `
    SELECT * FROM battle_challenges
    WHERE status = 'pending'
      AND expires_at > ?
      AND target_wallet IS NULL
  `;
  const params: any[] = [Date.now()];

  if (filters?.excludeWallet) {
    sql += ' AND challenger_wallet != ?';
    params.push(filters.excludeWallet);
  }
  if (filters?.minFee !== undefined) {
    sql += ' AND entry_fee >= ?';
    params.push(filters.minFee);
  }
  if (filters?.maxFee !== undefined) {
    sql += ' AND entry_fee <= ?';
    params.push(filters.maxFee);
  }

  sql += ' ORDER BY created_at DESC LIMIT 50';

  const stmt = db.prepare(sql);
  const rows = stmt.all(...params) as any[];
  return rows.map(mapRowToChallenge);
}
```

5. Add function to get challenges directed at a specific wallet:
```typescript
export function getDirectChallengesFor(walletAddress: string): BattleChallenge[] {
  const stmt = db.prepare(`
    SELECT * FROM battle_challenges
    WHERE status = 'pending'
      AND expires_at > ?
      AND target_wallet = ?
    ORDER BY created_at DESC
  `);
  const rows = stmt.all(Date.now(), walletAddress) as any[];
  return rows.map(mapRowToChallenge);
}
```

6. Update mapRowToChallenge to include new fields:
```typescript
targetWallet: row.target_wallet || undefined,
isOpen: !row.target_wallet,
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
  </verify>
  <done>
challengesDatabase has getOpenChallenges, getDirectChallengesFor, and createChallenge supports targetWallet
  </done>
</task>

<task type="auto">
  <name>Task 2: Add challenge REST endpoints</name>
  <files>
    backend/src/index.ts
  </files>
  <action>
Add REST endpoints to index.ts:

1. GET /api/challenges - List open challenges:
```typescript
import * as challengesDb from './db/challengesDatabase';

app.get('/api/challenges', (req, res) => {
  try {
    const { minFee, maxFee, wallet } = req.query;
    const challenges = challengesDb.getOpenChallenges({
      minFee: minFee ? parseFloat(minFee as string) : undefined,
      maxFee: maxFee ? parseFloat(maxFee as string) : undefined,
      excludeWallet: wallet as string | undefined,
    });
    res.json({ challenges });
  } catch (error) {
    console.error('[API] Error fetching challenges:', error);
    res.status(500).json({ error: 'Failed to fetch challenges' });
  }
});
```

2. GET /api/challenges/direct/:wallet - Get challenges targeting a specific wallet:
```typescript
app.get('/api/challenges/direct/:wallet', (req, res) => {
  try {
    const challenges = challengesDb.getDirectChallengesFor(req.params.wallet);
    res.json({ challenges });
  } catch (error) {
    console.error('[API] Error fetching direct challenges:', error);
    res.status(500).json({ error: 'Failed to fetch direct challenges' });
  }
});
```

3. POST /api/challenges - Create a new challenge:
```typescript
app.post('/api/challenges', express.json(), (req, res) => {
  try {
    const { challengerWallet, entryFee, leverage, duration, targetWallet, challengerUsername } = req.body;

    // Validate required fields
    if (!challengerWallet || !entryFee || !leverage || !duration) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Check pending challenge limit
    const pendingCount = challengesDb.getPendingChallengeCount(challengerWallet);
    if (pendingCount >= challengesDb.CHALLENGE_CONFIG.maxPendingPerUser) {
      return res.status(400).json({ error: 'Maximum pending challenges reached' });
    }

    const challenge = challengesDb.createChallenge({
      challengerWallet,
      challengerUsername,
      entryFee,
      leverage,
      duration,
      targetWallet: targetWallet || undefined,
    });

    res.status(201).json({ challenge });
  } catch (error) {
    console.error('[API] Error creating challenge:', error);
    res.status(500).json({ error: 'Failed to create challenge' });
  }
});
```

Note: express.json() middleware should already be applied globally, but ensure it's available for the POST body parsing.
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Backend starts without errors
Test: `curl http://localhost:3001/api/challenges` returns JSON with challenges array
  </verify>
  <done>
REST endpoints for listing open challenges, direct challenges, and creating challenges work
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WebSocket events for challenge notifications</name>
  <files>
    backend/src/index.ts
  </files>
  <action>
Enhance WebSocket handling for challenge events:

1. Add event for when a direct challenge is created targeting a player:
When createChallenge is called with targetWallet, emit to that wallet's socket if connected.

In the POST /api/challenges handler, after creating challenge:
```typescript
if (targetWallet) {
  // Notify target player of direct challenge
  const targetSocketId = battleManager.getSocketIdForWallet(targetWallet);
  if (targetSocketId) {
    io.to(targetSocketId).emit('direct_challenge_received', {
      challenge: {
        id: challenge.id,
        code: challenge.challengeCode,
        challengerWallet: challenge.challengerWallet,
        entryFee: challenge.entryFee,
        duration: challenge.duration,
        expiresAt: challenge.expiresAt,
      }
    });
  }
}
```

2. Add socket event handler for subscribing to open challenges updates:
```typescript
socket.on('subscribe_challenges', () => {
  socket.join('challenges');
  console.log(`[Socket] ${socket.id} subscribed to challenges`);
});

socket.on('unsubscribe_challenges', () => {
  socket.leave('challenges');
});
```

3. Broadcast when new open challenge created (in POST handler):
```typescript
if (!targetWallet) {
  io.to('challenges').emit('challenge_created', {
    challenge: {
      id: challenge.id,
      code: challenge.challengeCode,
      challengerWallet: challenge.challengerWallet,
      entryFee: challenge.entryFee,
      duration: challenge.duration,
      expiresAt: challenge.expiresAt,
    }
  });
}
```
  </action>
  <verify>
TypeScript compiles: `cd backend && npm run typecheck`
Backend starts and logs socket subscription events
  </verify>
  <done>
Direct challenge targets receive socket notification, open challenges room broadcasts new challenges
  </done>
</task>

</tasks>

<verification>
- [ ] `cd backend && npm run typecheck` passes
- [ ] Backend starts without errors
- [ ] GET /api/challenges returns array of open challenges
- [ ] POST /api/challenges creates challenge, returns challenge object
- [ ] Direct challenges with targetWallet are not shown in open challenges list
- [ ] GET /api/challenges/direct/:wallet returns challenges targeting that wallet
</verification>

<success_criteria>
1. Open challenges endpoint returns only pending, non-expired, open challenges
2. Direct challenge (with targetWallet) can be created
3. Direct challenges are only visible to the target wallet
4. Challenge creation respects max pending limit per user
5. WebSocket events notify players of new challenges
6. Filtering by stake amount works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/10-battle-core/10-02-SUMMARY.md`
</output>
