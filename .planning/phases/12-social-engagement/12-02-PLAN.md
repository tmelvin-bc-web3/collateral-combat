---
phase: 12-social-engagement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/battle/BattleChat.tsx
  - web/src/hooks/useBattleChat.ts
  - web/src/components/battle/ChatMessage.tsx
autonomous: true

must_haves:
  truths:
    - "Spectators can see chat messages scrolling in battle view"
    - "Users can send messages via input field"
    - "Users can add emoji reactions by clicking reaction button"
    - "Chat shows backing badges (Fighter 1 or Fighter 2 label) for bettors"
  artifacts:
    - path: "web/src/components/battle/BattleChat.tsx"
      provides: "Chat panel component for battle view"
      min_lines: 100
    - path: "web/src/hooks/useBattleChat.ts"
      provides: "Socket.IO chat hook"
      exports: ["useBattleChat"]
    - path: "web/src/components/battle/ChatMessage.tsx"
      provides: "Individual chat message with reactions"
      min_lines: 50
  key_links:
    - from: "web/src/components/battle/BattleChat.tsx"
      to: "useBattleChat hook"
      via: "hook consumption"
      pattern: "useBattleChat\\("
    - from: "web/src/hooks/useBattleChat.ts"
      to: "socket"
      via: "socket.emit/socket.on"
      pattern: "socket\\.(emit|on)"
---

<objective>
Create a Twitch-style chat panel component for the battle spectator view with emoji reactions and backing badges.

Purpose: Enable real-time social engagement during battles. Fast-scrolling chat with hype emotes creates the live sports atmosphere that drives viral sharing.

Output: BattleChat component, useBattleChat hook, ChatMessage component with reactions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/types/chat.ts
@web/src/lib/socket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBattleChat hook</name>
  <files>web/src/hooks/useBattleChat.ts</files>
  <action>
Create a new hook that manages chat WebSocket subscription and state:

```typescript
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { socket } from '@/lib/socket';

interface ChatMessage {
  id: string;
  battleId: string;
  senderWallet: string;
  senderDisplayName: string;
  senderLevel: number;
  senderRole: 'spectator' | 'fighter_1' | 'fighter_2';
  content: string;
  wasFiltered: boolean;
  timestamp: number;
  type: 'user' | 'system';
  reactions: Record<string, string[]>;
}

interface UseBattleChatOptions {
  battleId: string;
  fighter1Wallet?: string;
  fighter2Wallet?: string;
  userBackedFighter?: 'fighter_1' | 'fighter_2' | null;
}

export function useBattleChat({ battleId, fighter1Wallet, fighter2Wallet, userBackedFighter }: UseBattleChatOptions) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [canChat, setCanChat] = useState(true);
  const { publicKey } = useWallet();
  const lastMessageTime = useRef(0);

  // Subscribe to chat on mount
  useEffect(() => {
    if (!battleId) return;

    socket.emit('join_battle', battleId);

    const handleMessage = (message: ChatMessage) => {
      if (message.battleId === battleId) {
        setMessages(prev => [...prev.slice(-99), message]); // Keep last 100
      }
    };

    const handleReaction = (data: { battleId: string; messageId: string; emoji: string; wallet: string; action: 'add' | 'remove' }) => {
      if (data.battleId !== battleId) return;

      setMessages(prev => prev.map(msg => {
        if (msg.id !== data.messageId) return msg;

        const reactions = { ...msg.reactions };
        if (data.action === 'add') {
          if (!reactions[data.emoji]) reactions[data.emoji] = [];
          if (!reactions[data.emoji].includes(data.wallet)) {
            reactions[data.emoji] = [...reactions[data.emoji], data.wallet];
          }
        } else {
          if (reactions[data.emoji]) {
            reactions[data.emoji] = reactions[data.emoji].filter(w => w !== data.wallet);
            if (reactions[data.emoji].length === 0) delete reactions[data.emoji];
          }
        }
        return { ...msg, reactions };
      }));
    };

    const handleHistory = (history: ChatMessage[]) => {
      setMessages(history);
    };

    const handleError = (err: string) => {
      if (err.includes('balance') || err.includes('chat')) {
        setError(err);
        setCanChat(false);
      }
    };

    socket.on('chat_message', handleMessage);
    socket.on('reaction_update', handleReaction);
    socket.on('chat_history', handleHistory);
    socket.on('error', handleError);

    return () => {
      socket.off('chat_message', handleMessage);
      socket.off('reaction_update', handleReaction);
      socket.off('chat_history', handleHistory);
      socket.off('error', handleError);
    };
  }, [battleId]);

  const sendMessage = useCallback((content: string) => {
    if (!publicKey || !canChat) return false;

    // Client-side rate limit check (3 seconds)
    const now = Date.now();
    if (now - lastMessageTime.current < 3000) {
      setError('Please wait 3 seconds between messages');
      return false;
    }
    lastMessageTime.current = now;
    setError(null);

    socket.emit('send_chat_message', { battleId, content });
    return true;
  }, [battleId, publicKey, canChat]);

  const addReaction = useCallback((messageId: string, emoji: string) => {
    if (!publicKey) return;
    socket.emit('add_reaction', { battleId, messageId, emoji });
  }, [battleId, publicKey]);

  const removeReaction = useCallback((messageId: string, emoji: string) => {
    if (!publicKey) return;
    socket.emit('remove_reaction', { battleId, messageId, emoji });
  }, [battleId, publicKey]);

  // Determine backing badge for each sender
  const getBackingBadge = useCallback((senderWallet: string): 'fighter_1' | 'fighter_2' | null => {
    // This would require knowing which fighter each wallet backed
    // For now, return null - can be enhanced with spectator bet data
    return null;
  }, []);

  return {
    messages,
    sendMessage,
    addReaction,
    removeReaction,
    error,
    canChat,
    getBackingBadge,
    userBackedFighter,
  };
}
```
  </action>
  <verify>
    - File exists at web/src/hooks/useBattleChat.ts
    - `grep -n "useBattleChat" web/src/hooks/useBattleChat.ts` shows export
    - `cd web && pnpm typecheck` passes
  </verify>
  <done>useBattleChat hook manages WebSocket subscription, message state, reactions, and rate limiting</done>
</task>

<task type="auto">
  <name>Task 2: Create ChatMessage component with reactions</name>
  <files>web/src/components/battle/ChatMessage.tsx</files>
  <action>
Create the individual message component with Twitch-style layout and reactions:

```typescript
'use client';

import { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { cn } from '@/lib/utils';

const ALLOWED_EMOJIS = ['ðŸ”¥', 'ðŸ’€', 'ðŸš€', 'ðŸ’°', 'ðŸ¤¡', 'ðŸ’¯', 'ðŸ˜­', 'ðŸ˜‚'];

interface ChatMessageProps {
  id: string;
  senderDisplayName: string;
  senderRole: 'spectator' | 'fighter_1' | 'fighter_2';
  senderLevel: number;
  content: string;
  wasFiltered: boolean;
  reactions: Record<string, string[]>;
  type: 'user' | 'system';
  backingBadge?: 'fighter_1' | 'fighter_2' | null;
  onAddReaction: (emoji: string) => void;
  onRemoveReaction: (emoji: string) => void;
  currentWallet?: string;
}

export function ChatMessage({
  id,
  senderDisplayName,
  senderRole,
  senderLevel,
  content,
  wasFiltered,
  reactions,
  type,
  backingBadge,
  onAddReaction,
  onRemoveReaction,
  currentWallet,
}: ChatMessageProps) {
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);

  if (type === 'system') {
    return (
      <div className="text-xs text-[#ff5500]/70 italic py-1 px-2">
        {content}
      </div>
    );
  }

  const roleColor = {
    fighter_1: 'text-[#7fba00]',
    fighter_2: 'text-[#cc2200]',
    spectator: 'text-white/60',
  }[senderRole];

  const roleBadge = {
    fighter_1: 'F1',
    fighter_2: 'F2',
    spectator: null,
  }[senderRole];

  const backingColor = backingBadge === 'fighter_1' ? 'bg-[#7fba00]/20' : backingBadge === 'fighter_2' ? 'bg-[#cc2200]/20' : '';

  const hasReacted = (emoji: string) => reactions[emoji]?.includes(currentWallet || '');

  return (
    <div className={cn('group py-1 px-2 hover:bg-white/5 transition-colors', backingColor)}>
      {/* Message header */}
      <div className="flex items-center gap-1.5 text-xs">
        {/* Level badge */}
        <span className="text-[#ff5500]/50 text-[10px]">Lv{senderLevel}</span>

        {/* Fighter badge */}
        {roleBadge && (
          <span className={cn('px-1 py-0.5 rounded text-[10px] font-bold', roleColor, 'bg-current/20')}>
            {roleBadge}
          </span>
        )}

        {/* Backing badge */}
        {backingBadge && senderRole === 'spectator' && (
          <span className={cn(
            'px-1 py-0.5 rounded text-[10px]',
            backingBadge === 'fighter_1' ? 'text-[#7fba00] bg-[#7fba00]/10' : 'text-[#cc2200] bg-[#cc2200]/10'
          )}>
            {backingBadge === 'fighter_1' ? 'ðŸŸ¢' : 'ðŸ”´'}
          </span>
        )}

        {/* Username */}
        <span className={cn('font-medium', roleColor)}>{senderDisplayName}</span>
      </div>

      {/* Message content */}
      <div className="text-sm text-white/90 break-words">
        {content}
        {wasFiltered && <span className="text-white/30 text-xs ml-1">(filtered)</span>}
      </div>

      {/* Reactions */}
      {Object.keys(reactions).length > 0 && (
        <div className="flex flex-wrap gap-1 mt-1">
          {Object.entries(reactions).map(([emoji, wallets]) => (
            <button
              key={emoji}
              onClick={() => hasReacted(emoji) ? onRemoveReaction(emoji) : onAddReaction(emoji)}
              className={cn(
                'flex items-center gap-0.5 px-1.5 py-0.5 rounded-full text-xs transition-colors',
                hasReacted(emoji)
                  ? 'bg-[#ff5500]/30 text-white'
                  : 'bg-white/10 text-white/60 hover:bg-white/20'
              )}
            >
              <span>{emoji}</span>
              <span>{wallets.length}</span>
            </button>
          ))}
        </div>
      )}

      {/* Reaction picker (shows on hover) */}
      <div className={cn(
        'flex gap-1 mt-1 opacity-0 group-hover:opacity-100 transition-opacity',
        showEmojiPicker ? 'opacity-100' : ''
      )}>
        {ALLOWED_EMOJIS.map(emoji => (
          <button
            key={emoji}
            onClick={() => hasReacted(emoji) ? onRemoveReaction(emoji) : onAddReaction(emoji)}
            className={cn(
              'text-sm p-0.5 rounded hover:bg-white/20 transition-colors',
              hasReacted(emoji) ? 'bg-[#ff5500]/20' : ''
            )}
          >
            {emoji}
          </button>
        ))}
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    - File exists at web/src/components/battle/ChatMessage.tsx
    - `cd web && pnpm typecheck` passes
  </verify>
  <done>ChatMessage component renders messages with role badges, backing badges, and reaction support</done>
</task>

<task type="auto">
  <name>Task 3: Create BattleChat panel component</name>
  <files>web/src/components/battle/BattleChat.tsx</files>
  <action>
Create the main chat panel with Twitch-style fast-scrolling layout:

```typescript
'use client';

import { useState, useRef, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { cn } from '@/lib/utils';
import { useBattleChat } from '@/hooks/useBattleChat';
import { ChatMessage } from './ChatMessage';

interface BattleChatProps {
  battleId: string;
  fighter1Wallet?: string;
  fighter2Wallet?: string;
  userBackedFighter?: 'fighter_1' | 'fighter_2' | null;
  className?: string;
  collapsed?: boolean;
}

export function BattleChat({
  battleId,
  fighter1Wallet,
  fighter2Wallet,
  userBackedFighter,
  className,
  collapsed = false,
}: BattleChatProps) {
  const [inputValue, setInputValue] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { publicKey } = useWallet();

  const {
    messages,
    sendMessage,
    addReaction,
    removeReaction,
    error,
    canChat,
  } = useBattleChat({
    battleId,
    fighter1Wallet,
    fighter2Wallet,
    userBackedFighter,
  });

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputValue.trim()) return;

    if (sendMessage(inputValue.trim())) {
      setInputValue('');
    }
  };

  if (collapsed) {
    return null;
  }

  return (
    <div className={cn(
      'flex flex-col bg-black/60 backdrop-blur border border-white/10 rounded-lg overflow-hidden',
      className
    )}>
      {/* Header */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-white/10 bg-black/40">
        <span className="text-sm font-medium text-white/80">Live Chat</span>
        <span className="text-xs text-white/40">{messages.length} messages</span>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto min-h-[200px] max-h-[400px]">
        {messages.length === 0 ? (
          <div className="flex items-center justify-center h-full text-white/30 text-sm">
            No messages yet. Be the first!
          </div>
        ) : (
          messages.map(msg => (
            <ChatMessage
              key={msg.id}
              id={msg.id}
              senderDisplayName={msg.senderDisplayName}
              senderRole={msg.senderRole}
              senderLevel={msg.senderLevel}
              content={msg.content}
              wasFiltered={msg.wasFiltered}
              reactions={msg.reactions}
              type={msg.type}
              onAddReaction={(emoji) => addReaction(msg.id, emoji)}
              onRemoveReaction={(emoji) => removeReaction(msg.id, emoji)}
              currentWallet={publicKey?.toBase58()}
            />
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Error display */}
      {error && (
        <div className="px-3 py-2 bg-[#cc2200]/20 text-[#cc2200] text-xs">
          {error}
        </div>
      )}

      {/* Input */}
      <form onSubmit={handleSubmit} className="border-t border-white/10">
        {!publicKey ? (
          <div className="px-3 py-3 text-center text-white/40 text-sm">
            Connect wallet to chat
          </div>
        ) : !canChat ? (
          <div className="px-3 py-3 text-center text-white/40 text-sm">
            Deposit SOL to chat
          </div>
        ) : (
          <div className="flex gap-2 p-2">
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              placeholder="Send a message..."
              maxLength={280}
              className="flex-1 bg-white/5 border border-white/10 rounded px-3 py-2 text-sm text-white placeholder:text-white/30 focus:outline-none focus:border-[#ff5500]/50"
            />
            <button
              type="submit"
              disabled={!inputValue.trim()}
              className="px-4 py-2 bg-[#ff5500] hover:bg-[#ff5500]/80 disabled:bg-white/10 disabled:text-white/30 text-white font-medium rounded text-sm transition-colors"
            >
              Send
            </button>
          </div>
        )}
      </form>
    </div>
  );
}
```
  </action>
  <verify>
    - File exists at web/src/components/battle/BattleChat.tsx
    - `cd web && pnpm typecheck` passes
    - `cd web && pnpm build` succeeds
  </verify>
  <done>BattleChat panel with auto-scroll, wallet-gated input, and Twitch-style layout</done>
</task>

</tasks>

<verification>
1. `cd web && pnpm typecheck` passes
2. `cd web && pnpm build` succeeds
3. BattleChat component exists with messages list and input
4. ChatMessage component shows reactions with add/remove support
5. useBattleChat hook connects to WebSocket events
6. Rate limiting enforced client-side (3s between messages)
</verification>

<success_criteria>
- BattleChat component renders with header, messages, and input
- ChatMessage shows sender with role badge and level
- Emoji reactions appear on hover and can be toggled
- Input is disabled when wallet not connected or no PDA balance
- Auto-scrolls to bottom on new messages
- All frontend typechecks pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-social-engagement/12-02-SUMMARY.md`
</output>
