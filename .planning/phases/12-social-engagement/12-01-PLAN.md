---
phase: 12-social-engagement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/types/chat.ts
  - backend/src/services/chatService.ts
  - backend/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can add emoji reactions to chat messages"
    - "Users with zero PDA balance cannot send chat messages"
    - "Rate limiting enforces 1 message per 3 seconds"
  artifacts:
    - path: "backend/src/types/chat.ts"
      provides: "ChatMessage with reactions field"
      contains: "reactions: Record<string, string[]>"
    - path: "backend/src/services/chatService.ts"
      provides: "Wallet-gated chat with reactions"
      exports: ["chatService"]
  key_links:
    - from: "backend/src/services/chatService.ts"
      to: "backend/src/services/balanceService.ts"
      via: "getOnChainBalance check before sendMessage"
      pattern: "balanceService\\.getOnChainBalance"
---

<objective>
Extend the existing chat service to support emoji reactions on messages and wallet-gating with PDA balance verification.

Purpose: Enable Twitch-style engagement where spectators can react to hype moments. Wallet-gating with PDA balance (not just wallet connection) ensures only users with skin in the game can chat, reducing spam and abuse.

Output: Extended chatService with reaction support, balance-gated messaging, and tighter rate limiting (1 msg/3s per CONTEXT.md).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/services/chatService.ts
@backend/src/types/chat.ts
@backend/src/services/balanceService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emoji reactions to chat types and service</name>
  <files>backend/src/types/chat.ts, backend/src/services/chatService.ts</files>
  <action>
1. In `backend/src/types/chat.ts`:
   - Add `reactions: Record<string, string[]>` to ChatMessage interface (key = emoji, value = array of wallet addresses)
   - Add new ChatEventType: `reaction_added` | `reaction_removed`
   - Add ReactionEventData interface: `{ battleId, messageId, emoji, wallet, action: 'add' | 'remove' }`

2. In `backend/src/services/chatService.ts`:
   - Update sendMessage to initialize `reactions: {}` on new messages
   - Add `addReaction(battleId: string, messageId: string, emoji: string, wallet: string): boolean`
     - Validate emoji is in allowed set (common emotes: fire, skull, rocket, money, clown, 100, cry, laugh)
     - Prevent duplicate reactions from same wallet on same message/emoji
     - Max 8 unique emojis per message, max 20 reactors per emoji
     - Notify listeners with 'reaction_added' event
   - Add `removeReaction(battleId: string, messageId: string, emoji: string, wallet: string): boolean`
     - Remove wallet from reactions[emoji] array
     - Notify listeners with 'reaction_removed' event

3. Allowed emoji set (Unicode):
   - fire: ðŸ”¥
   - skull: ðŸ’€
   - rocket: ðŸš€
   - money: ðŸ’°
   - clown: ðŸ¤¡
   - 100: ðŸ’¯
   - cry: ðŸ˜­
   - laugh: ðŸ˜‚
  </action>
  <verify>
    - `grep -n "reactions:" backend/src/types/chat.ts` shows reactions field in ChatMessage
    - `grep -n "addReaction" backend/src/services/chatService.ts` shows method exists
    - `npm run typecheck` in backend passes
  </verify>
  <done>ChatMessage has reactions field, addReaction/removeReaction methods exist with allowed emoji validation</done>
</task>

<task type="auto">
  <name>Task 2: Add wallet-gating and tighter rate limiting</name>
  <files>backend/src/services/chatService.ts</files>
  <action>
1. Import balanceService at top: `import { balanceService } from './balanceService';`

2. Update sendMessage signature to accept async and check balance:
   - Change to `async sendMessage(...)`
   - Before any processing, check: `const balance = await balanceService.getOnChainBalance(wallet);`
   - If balance <= 0, return `{ success: false, code: 'insufficient_balance', error: 'Must have PDA balance > 0 to chat' }`

3. Tighten rate limiting per CONTEXT.md:
   - Change DUPLICATE_WINDOW_MS to 3000 (1 message per 3 seconds)
   - Add lastMessageTime check in checkSpam:
     ```typescript
     if (state && Date.now() - state.lastMessageTime < 3000) {
       return { allowed: false, shouldMute: false, reason: 'Please wait 3 seconds between messages' };
     }
     ```

4. Add balance check to addReaction as well:
   - Only users with balance > 0 can react
   - Reactions have separate rate limit: 1 reaction per second per user
  </action>
  <verify>
    - `grep -n "getOnChainBalance" backend/src/services/chatService.ts` shows balance check
    - `grep -n "3000" backend/src/services/chatService.ts` shows 3-second rate limit
    - `npm run typecheck` in backend passes
  </verify>
  <done>Chat messages and reactions require PDA balance > 0, rate limited to 1 msg per 3s</done>
</task>

<task type="auto">
  <name>Task 3: Add Socket.IO handlers for reactions</name>
  <files>backend/src/index.ts</files>
  <action>
1. Add client->server events to types.ts:
   - `add_reaction: (data: { battleId: string; messageId: string; emoji: string }) => void`
   - `remove_reaction: (data: { battleId: string; messageId: string; emoji: string }) => void`

2. Add server->client events to types.ts:
   - `reaction_update: (data: { battleId: string; messageId: string; emoji: string; wallet: string; action: 'add' | 'remove' }) => void`

3. In index.ts, add socket handlers near existing chat handlers:
   ```typescript
   socket.on('add_reaction', async (data) => {
     const wallet = getWalletForSocket(socket.id);
     if (!wallet) return socket.emit('error', 'Not registered');

     const success = await chatService.addReaction(data.battleId, data.messageId, data.emoji, wallet);
     if (success) {
       io.to(data.battleId).emit('reaction_update', {
         battleId: data.battleId,
         messageId: data.messageId,
         emoji: data.emoji,
         wallet,
         action: 'add'
       });
     }
   });

   socket.on('remove_reaction', async (data) => {
     const wallet = getWalletForSocket(socket.id);
     if (!wallet) return socket.emit('error', 'Not registered');

     const success = await chatService.removeReaction(data.battleId, data.messageId, data.emoji, wallet);
     if (success) {
       io.to(data.battleId).emit('reaction_update', {
         battleId: data.battleId,
         messageId: data.messageId,
         emoji: data.emoji,
         wallet,
         action: 'remove'
       });
     }
   });
   ```

4. Update getWalletForSocket helper if needed (should already exist from register_wallet handler)
  </action>
  <verify>
    - `grep -n "add_reaction" backend/src/index.ts` shows handler exists
    - `grep -n "reaction_update" backend/src/types.ts` shows event type exists
    - `npm run typecheck` in backend passes
    - `npm run dev` starts without errors
  </verify>
  <done>WebSocket events for reactions are wired up, broadcast to battle room</done>
</task>

</tasks>

<verification>
1. `cd backend && npm run typecheck` passes
2. `cd backend && npm run dev` starts without errors
3. Chat types include reactions field
4. sendMessage checks PDA balance before allowing message
5. addReaction/removeReaction methods exist and validate emoji set
6. Socket handlers for add_reaction/remove_reaction broadcast to room
</verification>

<success_criteria>
- ChatMessage interface has `reactions: Record<string, string[]>` field
- sendMessage returns 'insufficient_balance' error when PDA balance <= 0
- Rate limiting enforces 1 message per 3 seconds
- addReaction validates emoji is in allowed set (8 emojis)
- Socket.IO handlers broadcast reaction updates to battle room
- All backend typechecks pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-social-engagement/12-01-SUMMARY.md`
</output>
