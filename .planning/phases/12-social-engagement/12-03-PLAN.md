---
phase: 12-social-engagement
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/imageService.ts
  - backend/src/routes/share.ts
  - backend/package.json
autonomous: true
user_setup:
  - service: satori
    why: "Server-side image generation"
    env_vars: []
    dashboard_config: []

must_haves:
  truths:
    - "GET /api/share/battle/:id/image returns PNG image"
    - "Battle result card shows winner, PnL, duration, entry fee"
    - "Image has UFC-inspired fight card aesthetic"
  artifacts:
    - path: "backend/src/services/imageService.ts"
      provides: "Satori + Sharp image generation"
      exports: ["imageService"]
    - path: "backend/src/routes/share.ts"
      provides: "Share image API routes"
      exports: ["shareRouter"]
  key_links:
    - from: "backend/src/routes/share.ts"
      to: "backend/src/services/imageService.ts"
      via: "generateBattleResultCard call"
      pattern: "imageService\\.generate"
---

<objective>
Create server-side image generation for battle result graphics using Satori + Sharp with UFC-inspired fight card aesthetic.

Purpose: Twitter Web Intents do NOT support direct image uploads - images must be served via URL with proper Open Graph meta tags. Server-generated images enable rich previews when users share battle results.

Output: imageService with Satori + Sharp, share routes serving PNG images on demand.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/services/battleManager.ts
@web/src/lib/shareImageGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Satori and Sharp dependencies</name>
  <files>backend/package.json</files>
  <action>
1. Install satori and sharp:
   ```bash
   cd backend && npm install satori@0.10.14 sharp@0.33.5
   ```

2. Install satori types if available:
   ```bash
   cd backend && npm install -D @types/sharp
   ```

3. Download Inter font for Satori (required - Satori needs explicit fonts):
   - Create `backend/assets/fonts/` directory
   - Download Inter-Regular.ttf and Inter-Bold.ttf from Google Fonts
   - OR use a script to fetch them programmatically

For simplicity, use a font loader that fetches at runtime:
```bash
cd backend && npm install @fontsource/inter
```

Actually, Satori needs raw font buffers. Create a fonts utility:
- Download Inter from: https://fonts.google.com/specimen/Inter
- Save Inter-Regular.ttf and Inter-Bold.ttf to backend/assets/fonts/
  </action>
  <verify>
    - `grep "satori" backend/package.json` shows satori installed
    - `grep "sharp" backend/package.json` shows sharp installed
    - `ls backend/assets/fonts/` shows Inter font files (or verify font loading approach)
  </verify>
  <done>Satori and Sharp installed, font files available</done>
</task>

<task type="auto">
  <name>Task 2: Create imageService with Satori + Sharp</name>
  <files>backend/src/services/imageService.ts</files>
  <action>
Create the image generation service:

```typescript
import satori from 'satori';
import sharp from 'sharp';
import * as fs from 'fs';
import * as path from 'path';

// Font loading - load once at startup
let interRegular: ArrayBuffer | null = null;
let interBold: ArrayBuffer | null = null;

function loadFonts() {
  if (!interRegular) {
    const fontPath = path.join(__dirname, '../../assets/fonts/Inter-Regular.ttf');
    if (fs.existsSync(fontPath)) {
      interRegular = fs.readFileSync(fontPath).buffer;
    } else {
      console.warn('[ImageService] Inter-Regular.ttf not found, using fallback');
    }
  }
  if (!interBold) {
    const fontPath = path.join(__dirname, '../../assets/fonts/Inter-Bold.ttf');
    if (fs.existsSync(fontPath)) {
      interBold = fs.readFileSync(fontPath).buffer;
    } else {
      console.warn('[ImageService] Inter-Bold.ttf not found, using fallback');
    }
  }
}

interface BattleResultData {
  battleId: string;
  winner: {
    wallet: string;
    displayName: string;
    pnl: number;
    pnlPercent: number;
  };
  loser: {
    wallet: string;
    displayName: string;
    pnl: number;
    pnlPercent: number;
  };
  duration: number; // in seconds
  entryFee: number; // in SOL
  prizeWon: number; // in SOL
  tradeCount: number;
  maxLeverage: number;
  biggestSwing: number; // PnL percent
  endedAt: number;
}

interface FighterProfileData {
  wallet: string;
  displayName: string;
  wins: number;
  losses: number;
  winRate: number;
  elo: number;
  tier: string;
  bestStreak: number;
  totalPnl: number;
}

class ImageService {
  constructor() {
    loadFonts();
  }

  async generateBattleResultCard(data: BattleResultData): Promise<Buffer> {
    const fonts = this.getFonts();

    // UFC-inspired fight card design
    const svg = await satori(
      {
        type: 'div',
        props: {
          style: {
            display: 'flex',
            flexDirection: 'column',
            width: '1200px',
            height: '630px',
            background: 'linear-gradient(180deg, #1a1512 0%, #0a0908 100%)',
            fontFamily: 'Inter',
            position: 'relative',
          },
          children: [
            // Top accent bar
            {
              type: 'div',
              props: {
                style: {
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: '4px',
                  background: 'linear-gradient(90deg, #ff5500 0%, #ff8800 50%, #ff5500 100%)',
                },
              },
            },
            // Header
            {
              type: 'div',
              props: {
                style: {
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  padding: '30px 50px',
                },
                children: [
                  {
                    type: 'div',
                    props: {
                      style: { display: 'flex', alignItems: 'baseline' },
                      children: [
                        { type: 'span', props: { style: { color: '#ff5500', fontSize: '42px', fontWeight: 700 }, children: 'DEGEN' } },
                        { type: 'span', props: { style: { color: '#e8dfd4', fontSize: '42px', fontWeight: 700 }, children: 'DOME' } },
                      ],
                    },
                  },
                  { type: 'span', props: { style: { color: '#555', fontSize: '20px' }, children: 'BATTLE RESULT' } },
                ],
              },
            },
            // Main content - Fighter comparison
            {
              type: 'div',
              props: {
                style: {
                  display: 'flex',
                  flex: 1,
                  padding: '0 50px',
                  gap: '40px',
                },
                children: [
                  // Winner side
                  this.fighterCard(data.winner, true),
                  // VS divider
                  {
                    type: 'div',
                    props: {
                      style: {
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                      },
                      children: [
                        { type: 'span', props: { style: { color: '#ff5500', fontSize: '36px', fontWeight: 700 }, children: 'VS' } },
                      ],
                    },
                  },
                  // Loser side
                  this.fighterCard(data.loser, false),
                ],
              },
            },
            // Stats bar
            {
              type: 'div',
              props: {
                style: {
                  display: 'flex',
                  justifyContent: 'center',
                  gap: '60px',
                  padding: '30px 50px',
                  borderTop: '1px solid rgba(255,255,255,0.1)',
                },
                children: [
                  this.statBadge('DURATION', this.formatDuration(data.duration)),
                  this.statBadge('ENTRY FEE', `${data.entryFee.toFixed(2)} SOL`),
                  this.statBadge('PRIZE', `${data.prizeWon.toFixed(2)} SOL`),
                  this.statBadge('TRADES', data.tradeCount.toString()),
                  this.statBadge('MAX LEV', `${data.maxLeverage}x`),
                ],
              },
            },
            // Footer
            {
              type: 'div',
              props: {
                style: {
                  display: 'flex',
                  justifyContent: 'center',
                  padding: '20px',
                  borderTop: '1px solid rgba(255,255,255,0.05)',
                },
                children: [
                  { type: 'span', props: { style: { color: '#444', fontSize: '16px' }, children: 'degendome.xyz' } },
                ],
              },
            },
          ],
        },
      },
      {
        width: 1200,
        height: 630,
        fonts,
      }
    );

    // Convert SVG to PNG using Sharp
    return sharp(Buffer.from(svg)).png().toBuffer();
  }

  private fighterCard(fighter: { wallet: string; displayName: string; pnl: number; pnlPercent: number }, isWinner: boolean) {
    const pnlColor = fighter.pnl >= 0 ? '#7fba00' : '#cc2200';
    const pnlSign = fighter.pnl >= 0 ? '+' : '';

    return {
      type: 'div',
      props: {
        style: {
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          flex: 1,
          padding: '30px',
          background: isWinner ? 'rgba(127, 186, 0, 0.1)' : 'rgba(255, 255, 255, 0.02)',
          borderRadius: '16px',
          border: isWinner ? '2px solid rgba(127, 186, 0, 0.3)' : '1px solid rgba(255, 255, 255, 0.1)',
        },
        children: [
          // Winner badge
          isWinner && {
            type: 'div',
            props: {
              style: {
                background: '#7fba00',
                color: 'black',
                padding: '6px 20px',
                borderRadius: '20px',
                fontSize: '14px',
                fontWeight: 700,
                marginBottom: '16px',
              },
              children: 'WINNER',
            },
          },
          // Name
          {
            type: 'span',
            props: {
              style: { color: '#e8dfd4', fontSize: '28px', fontWeight: 600, marginBottom: '20px' },
              children: fighter.displayName,
            },
          },
          // PnL
          {
            type: 'span',
            props: {
              style: { color: pnlColor, fontSize: '48px', fontWeight: 700 },
              children: `${pnlSign}${fighter.pnlPercent.toFixed(1)}%`,
            },
          },
          // Wallet
          {
            type: 'span',
            props: {
              style: { color: '#555', fontSize: '14px', marginTop: '10px' },
              children: `${fighter.wallet.slice(0, 4)}...${fighter.wallet.slice(-4)}`,
            },
          },
        ].filter(Boolean),
      },
    };
  }

  private statBadge(label: string, value: string) {
    return {
      type: 'div',
      props: {
        style: {
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        },
        children: [
          { type: 'span', props: { style: { color: '#666', fontSize: '12px', textTransform: 'uppercase' }, children: label } },
          { type: 'span', props: { style: { color: '#e8dfd4', fontSize: '20px', fontWeight: 600 }, children: value } },
        ],
      },
    };
  }

  private formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  private getFonts() {
    const fonts: any[] = [];

    if (interRegular) {
      fonts.push({
        name: 'Inter',
        data: interRegular,
        weight: 400,
        style: 'normal',
      });
    }

    if (interBold) {
      fonts.push({
        name: 'Inter',
        data: interBold,
        weight: 700,
        style: 'normal',
      });
    }

    return fonts;
  }

  async generateFighterProfileCard(data: FighterProfileData): Promise<Buffer> {
    // Simplified version - can be expanded
    const fonts = this.getFonts();

    const svg = await satori(
      {
        type: 'div',
        props: {
          style: {
            display: 'flex',
            flexDirection: 'column',
            width: '600px',
            height: '315px',
            background: 'linear-gradient(180deg, #1a1512 0%, #0a0908 100%)',
            fontFamily: 'Inter',
            padding: '30px',
          },
          children: [
            // Header with branding
            {
              type: 'div',
              props: {
                style: { display: 'flex', justifyContent: 'space-between', marginBottom: '20px' },
                children: [
                  {
                    type: 'div',
                    props: {
                      style: { display: 'flex', alignItems: 'baseline' },
                      children: [
                        { type: 'span', props: { style: { color: '#ff5500', fontSize: '24px', fontWeight: 700 }, children: 'DEGEN' } },
                        { type: 'span', props: { style: { color: '#e8dfd4', fontSize: '24px', fontWeight: 700 }, children: 'DOME' } },
                      ],
                    },
                  },
                  { type: 'span', props: { style: { color: '#ff5500', fontSize: '16px', fontWeight: 600 }, children: data.tier.toUpperCase() } },
                ],
              },
            },
            // Fighter name and ELO
            {
              type: 'div',
              props: {
                style: { marginBottom: '20px' },
                children: [
                  { type: 'div', props: { style: { color: '#e8dfd4', fontSize: '36px', fontWeight: 700 }, children: data.displayName } },
                  { type: 'div', props: { style: { color: '#666', fontSize: '14px' }, children: `ELO: ${data.elo}` } },
                ],
              },
            },
            // Stats grid
            {
              type: 'div',
              props: {
                style: { display: 'flex', gap: '30px' },
                children: [
                  this.profileStat('RECORD', `${data.wins}W - ${data.losses}L`),
                  this.profileStat('WIN RATE', `${data.winRate.toFixed(0)}%`),
                  this.profileStat('BEST STREAK', `${data.bestStreak}W`),
                  this.profileStat('TOTAL P&L', `${data.totalPnl >= 0 ? '+' : ''}${data.totalPnl.toFixed(2)} SOL`),
                ],
              },
            },
          ],
        },
      },
      {
        width: 600,
        height: 315,
        fonts,
      }
    );

    return sharp(Buffer.from(svg)).png().toBuffer();
  }

  private profileStat(label: string, value: string) {
    return {
      type: 'div',
      props: {
        children: [
          { type: 'div', props: { style: { color: '#666', fontSize: '10px', textTransform: 'uppercase' }, children: label } },
          { type: 'div', props: { style: { color: '#e8dfd4', fontSize: '18px', fontWeight: 600 }, children: value } },
        ],
      },
    };
  }
}

export const imageService = new ImageService();
```
  </action>
  <verify>
    - File exists at backend/src/services/imageService.ts
    - `grep -n "satori" backend/src/services/imageService.ts` shows import
    - `grep -n "sharp" backend/src/services/imageService.ts` shows import
    - `cd backend && npm run typecheck` passes
  </verify>
  <done>imageService generates battle result cards and fighter profile cards using Satori + Sharp</done>
</task>

<task type="auto">
  <name>Task 3: Create share routes for image serving</name>
  <files>backend/src/routes/share.ts, backend/src/index.ts</files>
  <action>
1. Create the share routes file:

```typescript
// backend/src/routes/share.ts
import { Router, Request, Response } from 'express';
import { imageService } from '../services/imageService';
import { battleManager } from '../services/battleManager';
import { eloService } from '../services/eloService';

export const shareRouter = Router();

// GET /api/share/battle/:id/image - Serve battle result image
shareRouter.get('/battle/:id/image', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    // Get battle data
    const battle = battleManager.getBattle(id);
    if (!battle || battle.status !== 'completed') {
      return res.status(404).json({ error: 'Battle not found or not completed' });
    }

    // Build result data
    const player1 = battle.players[0];
    const player2 = battle.players[1];

    if (!player1 || !player2) {
      return res.status(400).json({ error: 'Battle missing players' });
    }

    const winner = battle.winnerId === player1.walletAddress ? player1 : player2;
    const loser = battle.winnerId === player1.walletAddress ? player2 : player1;

    const resultData = {
      battleId: battle.id,
      winner: {
        wallet: winner.walletAddress,
        displayName: winner.walletAddress.slice(0, 4) + '...' + winner.walletAddress.slice(-4),
        pnl: winner.finalPnl || winner.account.totalPnlPercent,
        pnlPercent: winner.account.totalPnlPercent,
      },
      loser: {
        wallet: loser.walletAddress,
        displayName: loser.walletAddress.slice(0, 4) + '...' + loser.walletAddress.slice(-4),
        pnl: loser.finalPnl || loser.account.totalPnlPercent,
        pnlPercent: loser.account.totalPnlPercent,
      },
      duration: battle.endedAt && battle.startedAt ? Math.floor((battle.endedAt - battle.startedAt) / 1000) : 300,
      entryFee: battle.config.entryFee,
      prizeWon: battle.prizePool * 0.95, // After 5% fee
      tradeCount: (player1.trades?.length || 0) + (player2.trades?.length || 0),
      maxLeverage: Math.max(
        ...player1.trades?.map(t => t.leverage) || [1],
        ...player2.trades?.map(t => t.leverage) || [1]
      ),
      biggestSwing: 0, // Could be calculated from trade history
      endedAt: battle.endedAt || Date.now(),
    };

    // Generate image
    const imageBuffer = await imageService.generateBattleResultCard(resultData);

    // Set headers for image response
    res.set({
      'Content-Type': 'image/png',
      'Cache-Control': 'public, max-age=86400', // Cache for 24 hours
      'Content-Length': imageBuffer.length,
    });

    return res.send(imageBuffer);
  } catch (error) {
    console.error('[ShareRouter] Error generating battle image:', error);
    return res.status(500).json({ error: 'Failed to generate image' });
  }
});

// GET /api/share/fighter/:wallet/image - Serve fighter profile card
shareRouter.get('/fighter/:wallet/image', async (req: Request, res: Response) => {
  try {
    const { wallet } = req.params;

    // Get fighter stats
    const stats = eloService.getPlayerStats(wallet);
    if (!stats) {
      return res.status(404).json({ error: 'Fighter not found' });
    }

    const profileData = {
      wallet,
      displayName: wallet.slice(0, 4) + '...' + wallet.slice(-4),
      wins: stats.wins,
      losses: stats.losses,
      winRate: stats.totalBattles > 0 ? (stats.wins / stats.totalBattles) * 100 : 0,
      elo: stats.elo,
      tier: stats.tier,
      bestStreak: stats.currentStreak, // Could track best streak separately
      totalPnl: 0, // Would need to aggregate from battle history
    };

    const imageBuffer = await imageService.generateFighterProfileCard(profileData);

    res.set({
      'Content-Type': 'image/png',
      'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
      'Content-Length': imageBuffer.length,
    });

    return res.send(imageBuffer);
  } catch (error) {
    console.error('[ShareRouter] Error generating fighter image:', error);
    return res.status(500).json({ error: 'Failed to generate image' });
  }
});
```

2. In backend/src/index.ts, mount the router:
   - Add import: `import { shareRouter } from './routes/share';`
   - Add route: `app.use('/api/share', shareRouter);`
  </action>
  <verify>
    - File exists at backend/src/routes/share.ts
    - `grep -n "shareRouter" backend/src/index.ts` shows router mounted
    - `cd backend && npm run typecheck` passes
    - `cd backend && npm run dev` starts (test endpoint manually if desired)
  </verify>
  <done>Share routes serve PNG images for battle results and fighter profiles</done>
</task>

</tasks>

<verification>
1. `cd backend && npm run typecheck` passes
2. `cd backend && npm run dev` starts without errors
3. Satori and Sharp packages installed
4. Font files exist in backend/assets/fonts/ (or alternative loading works)
5. GET /api/share/battle/:id/image returns PNG
6. GET /api/share/fighter/:wallet/image returns PNG
</verification>

<success_criteria>
- Satori 0.10.x and Sharp 0.33.x installed
- imageService exports generateBattleResultCard and generateFighterProfileCard
- Battle result card shows winner badge, both fighters' PnL, stats bar
- Fighter profile card shows record, ELO, tier, win rate
- Images served with correct Content-Type: image/png
- Images cached with Cache-Control headers
</success_criteria>

<output>
After completion, create `.planning/phases/12-social-engagement/12-03-SUMMARY.md`
</output>
