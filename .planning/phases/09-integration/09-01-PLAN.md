---
phase: 09-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/balanceService.ts
  - backend/tests/integration/failure-scenarios.test.ts
  - backend/tests/integration/economic-invariants.test.ts
  - docs/FAILURE-SCENARIOS.md
autonomous: true

must_haves:
  truths:
    - "All failure scenarios documented with expected behavior"
    - "Automated tests verify failure handling for critical paths"
    - "Solvency invariants verified: total_payouts + fees <= total_pool"
    - "Global vault reconciliation verifies vault >= sum of liabilities"
  artifacts:
    - path: "docs/FAILURE-SCENARIOS.md"
      provides: "Failure scenario documentation for all game modes"
      contains: "Transaction Failures"
    - path: "backend/tests/integration/failure-scenarios.test.ts"
      provides: "Automated failure scenario tests"
      contains: "describe.*Failure Scenarios"
    - path: "backend/tests/integration/economic-invariants.test.ts"
      provides: "Solvency invariant tests"
      contains: "describe.*Economic Invariants"
    - path: "backend/src/services/balanceService.ts"
      provides: "Global vault solvency check function"
      contains: "verifyGlobalVaultSolvency"
  key_links:
    - from: "backend/tests/integration/failure-scenarios.test.ts"
      to: "balanceService.verifyAndLockBalance"
      via: "mock and test"
      pattern: "verifyAndLockBalance"
    - from: "backend/tests/integration/economic-invariants.test.ts"
      to: "balanceDatabase.gameModeBalances"
      via: "property tests"
      pattern: "getAllGameModeBalances"
---

<objective>
Document failure scenarios and verify economic model correctness

Purpose: Ensure on-chain/off-chain state consistency under failure conditions and verify solvency invariants hold before mainnet (INT-01 + INT-03)
Output: Failure scenario documentation, automated failure tests, economic invariant tests, global vault monitoring function
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-integration/09-CONTEXT.md
@.planning/phases/09-integration/09-RESEARCH.md
@backend/src/db/balanceDatabase.ts
@backend/src/db/failedPayoutsDatabase.ts
@backend/src/services/balanceService.ts
@backend/src/utils/fees.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Document failure scenarios and add global vault solvency check</name>
  <files>
    docs/FAILURE-SCENARIOS.md
    backend/src/services/balanceService.ts
  </files>
  <action>
Create comprehensive failure scenario documentation at docs/FAILURE-SCENARIOS.md covering:

1. **Transaction Failures** - RPC timeout during lock, settlement tx failure, confirmation timeout
2. **Backend Crashes** - Crash mid-settlement, crash during payout
3. **RPC Issues** - Stale balance reads, network partitions
4. **Game Mode Specific** - Oracle, Battle, Spectator, Draft edge cases

For each scenario document:
- What can go wrong
- Expected system behavior
- Recovery mechanism
- Warning signs to monitor

Use security audit format with severity ratings (CRITICAL/HIGH/MEDIUM/LOW).

Also add `verifyGlobalVaultSolvency()` function to balanceService.ts that:
1. Gets global vault balance from getGlobalVaultBalance()
2. Gets all game mode balances from getAllGameModeBalances()
3. Calculates total liabilities (sum of locked - paidOut for each mode)
4. Returns { solvent: boolean, vaultBalance: number, totalLiabilities: number, breakdown: Record<GameMode, ...> }

Reference existing infrastructure: failedPayoutsDatabase for recovery, cleanupStalePendingTransactions for stale tx handling.

Failure policy per CONTEXT.md: "Favor house (safe) - if unclear, hold funds for manual review rather than auto-refunding"
  </action>
  <verify>
- docs/FAILURE-SCENARIOS.md exists with all failure categories documented
- balanceService.ts exports verifyGlobalVaultSolvency function
- npm run typecheck passes
  </verify>
  <done>
Failure scenarios documented with severity ratings. Global vault solvency check function implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create failure scenario integration tests</name>
  <files>
    backend/tests/integration/failure-scenarios.test.ts
  </files>
  <action>
Create integration tests at backend/tests/integration/failure-scenarios.test.ts covering:

**Transaction Failures:**
```typescript
describe('Transaction Failures', () => {
  it('should cancel pending transaction on lock failure (RPC timeout)', async () => {
    // Mock RPC timeout on transferToGlobalVault
    // Verify pending transaction cancelled
    // Verify available balance unchanged
  });

  it('should add to failedPayouts on settlement failure', async () => {
    // Lock funds successfully
    // Mock settlement failure
    // Verify failedPayoutsDatabase.addFailedPayout called
  });
});
```

**Backend Crash Recovery:**
```typescript
describe('Backend Crash Recovery', () => {
  it('should mark stale pending transactions as failed via cleanupStalePendingTransactions', async () => {
    // Create pending transaction with old timestamp
    // Call cleanupStalePendingTransactions
    // Verify transaction marked failed
  });
});
```

**RPC Issues:**
```typescript
describe('RPC Issues', () => {
  it('should account for pending debits in available balance', async () => {
    // User has 1 SOL on-chain
    // Create pending debit of 0.5 SOL
    // Verify getAvailableBalance returns 0.5 SOL
  });
});
```

Use Jest mocks for balanceService and failedPayoutsDatabase functions.
Test critical paths that handle real money - focus on preventing fund loss.
  </action>
  <verify>
- backend/tests/integration/failure-scenarios.test.ts exists
- npm test -- failure-scenarios passes (or equivalent test command)
  </verify>
  <done>
Failure scenario tests pass. Critical paths (RPC timeout, settlement failure, crash recovery) have automated coverage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create economic invariant tests</name>
  <files>
    backend/tests/integration/economic-invariants.test.ts
  </files>
  <action>
Create economic invariant tests at backend/tests/integration/economic-invariants.test.ts covering:

**Solvency Invariants:**
```typescript
describe('Economic Invariants', () => {
  describe('Solvency', () => {
    it('should maintain: total_payouts + fees <= total_pool', () => {
      // Property test: for any set of bets and winner, verify invariant
    });

    it('should maintain: paidOut <= locked for each game mode', () => {
      // Verify canPayoutFromGameMode rejects when paidOut > locked
    });

    it('should verify vault >= total liabilities via verifyGlobalVaultSolvency', () => {
      // Setup mock balances
      // Call verifyGlobalVaultSolvency
      // Verify result.solvent is true when vault >= liabilities
      // Verify result.solvent is false when vault < liabilities
    });
  });
});
```

**Fee Accuracy:**
```typescript
describe('Fee Accuracy', () => {
  it('should use consistent fee: contract 500 BPS matches backend PLATFORM_FEE_BPS', () => {
    // Import PLATFORM_FEE_BPS from fees.ts
    // Verify equals 500
    // Document that contract lib.rs line 18 uses same value
  });

  it('should calculate distributable pool correctly', () => {
    // Test calculateDistributablePool from fees.ts
    // losingPool * (1 - 500/10000) = losingPool * 0.95
  });
});
```

**Edge Cases:**
```typescript
describe('Edge Cases', () => {
  it('should handle draw scenario: full refund without fee', () => {
    // Verify draw returns full bet amount (contract line 913-917)
  });

  it('should handle single-sided pool: winner gets bet back', () => {
    // If losing_pool = 0, winner gets bet_amount back (contract line 993-995)
  });
});
```

Reference RESEARCH.md patterns. Focus on property-based tests where feasible.
  </action>
  <verify>
- backend/tests/integration/economic-invariants.test.ts exists
- npm test -- economic-invariants passes (or equivalent test command)
- All solvency invariant tests pass
  </verify>
  <done>
Economic invariant tests pass. Solvency (total_payouts + fees <= total_pool), fee accuracy (500 BPS), and edge cases (draw, single-sided) verified.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. docs/FAILURE-SCENARIOS.md documents all failure categories with severity ratings
2. backend/src/services/balanceService.ts exports verifyGlobalVaultSolvency
3. backend/tests/integration/failure-scenarios.test.ts tests pass
4. backend/tests/integration/economic-invariants.test.ts tests pass
5. npm run typecheck passes
</verification>

<success_criteria>
- All failure scenarios documented for security audit review
- Automated tests cover: RPC timeout, settlement failure, crash recovery, stale balance handling
- Solvency invariants verified via tests
- Global vault reconciliation function ready for runtime monitoring
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration/09-01-SUMMARY.md`
</output>
